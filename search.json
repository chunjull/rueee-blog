[{"title":"#98 Promise","date":"2024-05-09T16:00:00.000Z","url":"/uncategorized/20240510/1163736102/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[[" ",""]],"content":"Promise 物件表示一個「或已實現、或以拒絕」的函式結果。 快速了解ES6 新增了一種名為 Promise 的特殊物件，使用目的為：表示非同步運算的最終結果是成功或失敗。換句話說， Promise 的任務是確保「非同步函式的結果」可以用已被預期的方式處理：要不是被履行（resolve），就是被拒絕（reject）。 Promise 結構透過新增一個 Promise 物件，搭配箭頭函式的方式，可以展示成功或失敗的最終結果。 另外，如果要提供一個函式 Promise 功能，可以透過讓它回傳一個 Promise 物件來達成： 當 Promise 被完成時，可以呼叫 resolve() ，再將取得的資料傳遞出去；當拒絕 Promise 時，則呼叫 reject() 來拒絕。 Promise 狀態pending, fulfilled, rejected, .then()一般來說， Promise 物件有以下三種狀態： pending：初始狀態，不是 fulfilled 或 rejected 。 fulfilled：表示操作成功完成。 rejected：表示操作失敗。 此外，還可以透過 .then() 依序串連執行多個 Promise 功能。 Promise 方法 Promise 有兩種較常見的處理方法： Promise.all 與 Promise.race 。 Promise.all 的功能為：直到目標函式都回覆 resolve 才會繼續後續行為。然而，當執行過程中，只要有任何一個 Promise 物件發生錯誤例外，或是有 Promise 發生 reject 情況，就會立即回傳一個 rejected 狀態的 Promise 物件。此方法不在乎目標函式的先後順序，只關心其是否都已經完成。 Promise.race 的功能為：只要有其中一個目標函式被 resolve ，就會執行下一步驟。雖然，只要有一個函式完成任務，就會進行後續行為，但這不表示「其他未完成的函式會取消任務」，這些函式仍然會被執行。 了解更多 Kuro－同步與非同步：本文最主要的參考範例。 MDN－使用 Promise：了解如何使用 Promise 。 MDN－Promise：了解更多的 Promise 使用規則。 MDN－Promise.all：了解 Promise.all 的意義。 MDN－Promise.race：了解 Promise.race 的意義。 MDN－.then()：了解 .then() 的意義。 "},{"title":"#97 立即函式","date":"2024-05-08T16:00:00.000Z","url":"/javascript/20240509/2084810320/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"立即函式（IIFE）的目的：減少全域變數產生，並避免變數名稱衝突。 快速了解「立即函式」指「可以立即被呼叫的函式表達式」（Immediately Invoked Function Expression, IIFE）。立即函式最主要的目的是：避免污染到全域環境，並造成污染與衝突。因此，立即函式會限制變數的作用域，將該變數的有效範圍限制在「立即函式的內層」，只能在立即函式內被取得，無法在外層呼叫。 立即函式結構首先，來回顧一下原始的函式結構： 如果我們希望在定義函式的當下就呼叫它，使其變成立即函式，需要注意兩個步驟： 先使用小括號 () 將這個函式包起來。 並在最後方再加一個小括號 () ，使我們可以呼叫它。 如果該函式只需要在宣告的當下執行，之後不會再呼叫，則可以省去函式命名。如此，由上述步驟得到的立即函式會是下面這個樣子： 立即函式特性立即函式具有以下幾種特性： 是「具名函式」，也是可以自我執行的「匿名函式」。 立即函式會透過具名函式——即「函式表達式」——來執行，無法在「立即函式的範圍外層」被呼叫。同時，立即函式也可以是不具名的匿名函式，並能夠自我執行。 變數有效範圍只在「立即函式的內層」。 立即函式的變數有效範圍只在「立即函式的內層」，換言之，只能在立即函式內被取得，在外層無法取得變數。 減少全域變數的產生。 因為上述限制作用域的關係，立即函式可以減少全域變數產生，同時可以避免「變數名稱衝突」的問題。 能夠傳遞參數且回傳值。 立即函式本身是函式表達式，可以傳參數、回傳值，並以變數接收回傳值。 立即函式傳遞變數假設我們想透過迴圈與 setTimeout 來做到「在五秒鐘內，每秒依序透過 console.log 印出 1 2 3 4 5 」的範例。 以上述程式碼為例，如果直接使用迴圈搭配 setTimeout 的寫法，設定每秒印出 i 值，實際執行結果會是「在『一秒鐘之後』同時印出『五次 5 』」。造成這種結果，是因為「切分變數有效範圍的最小單位是 function 」。每一次執行 setTimeout 時，裡面 console.log(i); 的 i 變數是從函式的「外層」取得， for 迴圈並不會等 setTimeout 結束後才繼續。因此，當 setTimeout 內的回呼函式執行時，拿到的 i 值已經是跑完 for 迴圈的 5 。 為了保留每一次執行迴圈時「當下的」那個 i 值，可以使用「立即函式」的方式將其包覆住，並將 i 值作為參數傳入，同時把印出時間設定為 x 秒，即可順利做出「每秒依序印出 1 2 3 4 5 」的程式碼。 void 運算子在 JS 中，有一種運算子名為 void ，其功能為：接收任意的運算式或值，並回傳 undefined 。 一般來說，無論 void 運算子後面的值為何，都會回傳 undefined 的結果。但若後方的值是一個「立即函式」，其回傳結果則會是該立即函式的運算結果。 然而，如果再去呼叫該函式時，則是會出現 Uncaught ReferenceError: saySomething is not defined 的錯誤。 小知識 立即函式不符合 ASI 規則，所以無法自動插入分號。但若在立即函式前方或後方補上分號，即可正確執行。 雖然 void 運算子的使用情境不多，但有些開發者會習慣在此類一次性呼叫的立即函式前方，加上 void 以增加程式碼的可讀性。 了解更多 Kuro－Callback Function 與 IIFE：本文最主要的參考範例。 MDN－IIFE：了解立即函式的意義。 MDN－void 運算子：了解 void 運算子的意義。 Kuro－JS 冷知識: 你所不知道的 void： void 運算子的補充介紹。 "},{"title":"#96 回呼函式","date":"2024-05-07T16:00:00.000Z","url":"/javascript/20240508/969311364/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"回呼函式指「在某一函式執行時或執行後，依條件或依序去執行所傳遞進來的函式」。 快速了解CallBack 被翻譯為「回調、回函、回呼」等意思。CallBack function 則是指「能藉由參數通往另一函式的函式」，簡單來說，就是「把函式當作另一個函式的參數，透過另一個函式來呼叫它」。當某函式在滿足特定條件才會「被動地」去執行時，可以稱其為「回呼函式」。以下分享回呼函式的兩種常見情境： 事件。 控制多個函式之間執行的順序。 事件驅動案例以「辦公室電話響了」、「去接電話」這個事件為例： office 透過 addEventListener 方法註冊了一個「電話響」的事件，當該事件被觸發時，它會去執行指定的第二個參數——「接電話」這個「函式」。 定時器案例以定時器函式 window.setTimeout 為例，假設我們需要設定「間隔某段時間後再執行某件事」，並控制多函式間的執行順序： 為了確保執行順序是先 funcA 後 funcB ，要先在 funcA 加上參數 callback ，並加上判斷式「若參數 callback 是函式就呼叫它」。如此一來，無論 funcA 在執行時要等多久， funcB 都會等到 console.log(&#39;function A&#39;); 完成後才執行。 CallBack Hell如果函式之間的相依過深，可能會造成多層巢狀的「回呼地獄」（CallBack Hell）。 像上面這樣，不斷向下回呼的函式結構，就被稱為「回呼地獄」。 了解更多 Kuro－Callback Function 與 IIFE：本文最主要的參考範例。 MDN－回呼函式：了解回呼函式的概念。 MDN－setTimeout：了解 setTimeout 的延伸用法。 Ray－RE：從零開始的學習 JS 生活-第二十五日：欣賞回呼地獄造成的「波動拳」動畫。 "},{"title":"#95 淺拷貝與深拷貝","date":"2024-05-06T16:00:00.000Z","url":"/javascript/20240507/124095393/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"淺拷貝會共用同一個記憶體空間；深拷貝則使用兩個不同的記憶體空間。 快速了解JS 資料型別分為兩大類：基本型別與物件型別。兩者最大的差異在於： 基本型別使用 Pass by value 的方式傳遞參數，複製變數時會直接複製「值」（value）。會將「值」真實地複製一份，因此不會互相影響到最終結果。 物件型別則使用。Pass by reference 的方式傳遞參數，複製變數時則會複製「址」（address）。複製出來的「值」與原本的變數之間會互相影響。物件型別這種「複製的址會和原始變數共用同一記憶體空間」的複製方法，被稱為「淺拷貝」（Shallow Copy）；而透過特定方法，使「複製的址和原始變數使用不同記憶體空間」的方法，則被稱為「深拷貝」（Deep Copy）。 淺拷貝淺拷貝只拷貝「物件或陣列中的第一層資料」，第二層以上的資料不會真的拷貝，而是會參考到和原本相同的物件或陣列實體，因此會互相影響。常見的 JS 拷貝工具都是淺拷貝，例如：使用其餘運算子 … 、使用內建方法 Object.assign() 等。 在上述程式碼中， data 中的陣列沒有真的被拷貝，a 和 b 物件中的 data 仍參考到同一個陣列實體。b 對 data 的操作影響到 a 的 data ，使最終印出結果是 4 。 深拷貝深拷貝會「完全拷貝物件底下所有層次的資料」，建立兩個完全獨立的物件實體，且互相不影響。 在上述程式碼中，先使用 JSON.stringify() 將物件字串化（Serialize），並使用 JSON.parse() 根據字串化的資料重新建立物件結構，完成深拷貝。經過深拷貝後，兩個物件完全獨立、不互相影響，變數 b 對 data 的操作不會影響到變數 a 的 data ，因此最終印出結果是 1 。 小知識 物件或陣列中，還包含其他的物件或陣列，才會產生「層次」。 了解更多 Andy Chen－關於JS中的淺拷貝(shallow copy)以及深拷貝(deep copy)：了解淺拷貝、深拷貝的差異。 城市碼農－JS 中的淺拷貝 (Shallow copy) 與深拷貝 (Deep copy) 原理與實作：透過案例了解拷貝方式的差異。 彭彭－JavaScript 物件的淺拷貝、深拷貝：了解淺拷貝、深拷貝的差異。 "},{"title":"#94 JS 型別比較與轉換規則","date":"2024-05-05T16:00:00.000Z","url":"/javascript/20240506/2224158138/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"JS 是一種弱型別的動態程式語言，不必特別宣告變數型別，程式運作時型別會自動轉換。 快速了解JS 是動態型別且弱型別的程式語言，其型別轉換有兩種情境：顯性轉換與隱性轉換。 靜態型別 v.s. 動態型別動態型別與靜態型別的區別在於：在編譯階段或執行階段「確立型別」。 靜態型別：在編譯階段時確立型別。優點是可避免執行階段發生型別錯誤、提供重構輔助與更多的文件形式；缺點是程式語法繁瑣、彈性不足，只能檢查出執行階段前的簡單錯誤。 動態型別：在執行階段時確立型別。優點是語法簡潔、具有高度彈性；缺點是型別錯誤在執行階段才會呈現出來，效能表現較不理想，編輯輔助工具較為缺乏，依賴慣例或實體文件來得知API使用方式。 強型別 v.s. 弱型別強型別與弱型別的區別在於：當開發者未告知「進行型別轉換」時，在執行階段是否會因為型別錯誤而自動轉換。 強型別：偏向不容許隱性型別轉換，型別檢查上較為嚴格。 弱型別：偏向容許隱性型別轉換，型別檢查上較為寬鬆。 顯性轉換 v.s. 隱性轉換 顯性轉換：在程式碼中，有明確對變數執行型別轉換。常見的顯性轉換包含：字串轉數字、數字轉字串、數字或字串轉布林值。 隱性轉換：在程式碼中沒有明確對變數執行型別轉換，而是 JS 自動轉型。 小知識 靜態型別語言不一定是強型別語言；動態型別語言也不一定是弱型別語言。 強、弱型別的差異可以視為「編譯器或直譯器對型別檢查的寬容程度」，或者看成是「允許編譯器或直譯器自作主張的程度」。 了解更多 MDN－JavaScript 的資料型別與資料結構：了解 JS 的動態型別。 Jenifer－靜態語言 &#x2F; 動態語言、強型別 &#x2F; 弱型別、静態作用域 &#x2F; 動態作用域：了解程式語言的既種常見差異。 OneJar－你不可不知的 JavaScript 二三事#Day2：資料型態的夢魘——動態型別加弱型別(1)：了解靜態、動態型別的差異。 OneJar－你不可不知的 JavaScript 二三事#Day3：資料型態的夢魘——動態型別加弱型別(2)：了解強、弱型別的差異。 Summer－你懂 JavaScript 嗎？#8 強制轉型（Coercion）：深入了解 JS 的型別轉換規則。 "},{"title":"#93 自動插入分號（ASI）","date":"2024-05-04T16:00:00.000Z","url":"/javascript/20240505/3746670075/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"ASI 會幫程式碼自動帶入分號，但仍有所限制。 快速了解自動插入分號（Automatic Semicolon Insertion），簡稱「ASI」。顧名思義，JS 允許開發者不加上分號，因為它會自動帶入。 不會發生 ASI 的狀況ASI 比較容易出現錯誤的規則，大約就是新的一行有以下幾種開頭： ( 、 [ 、 / 通常會導致程式出錯： 大部分算數運算子 + 、 - 、 * 、 % 會影響執行結果： 逗號 , 或點運算子 . 可能會導致程式出錯或影響執行結果： 可以在上述情況的程式碼前方加入分號 ; ，以修正錯誤： 小知識 JS 的風格管理器 ESLint 中的 Standard 模式也採用 ASI 的方式。 空的陳述式、 var 陳述式、表達陳述式、 do-while 、 continue 、 break 、 return 、 throw 等程式碼都容易受到 ASI 影響。 了解更多 Ray－JavaScript 核心觀念(12)-運算子、型別與文法-ASI 自動插入分號：了解 ASI 的意義。 ShawnL 林奇璇－JavaScript 深入淺出 Automatic Semicolon Insertion 自動插入分號機制：了解 ASI 的各種情況。 "},{"title":"#92 JS 名詞比較","date":"2024-05-03T16:00:00.000Z","url":"/javascript/20240504/1637140423/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"比較 not defined 與 undefined 、單執行緒與多執行緒的差異。 快速了解變數定義狀態一個變數的定義狀態通常可以分為兩種： not defined 與 undefined 。 not defined：記憶體上沒有準備該變數的存放空間。 undefined：記憶體已準備該變數的存放空間，但尚未賦值。在開發時盡可能避免將 undefined 的值賦予到變數上，如果需要賦予空值在一個變數上，建議使用 null 。 null 會指出一個變數不存在的狀態； undefined 則是代表一個變數還沒被賦予值、尚未初始化的狀態。 執行緒行程（process）是 CPU 分配資源的最小單位，即「運行中的程式」。而執行緒（Thread）則是行程中的一部份，一個行程至少包含一或多個執行緒。執行緒可以分成兩種類別：單執行緒與多執行緒。 單執行緒：一次只能執行一項任務。 多執行緒：可以執行多項任務。JS 是單執行緒的程式語言，遇到多項任務時會「按照順序執行」，尚未被執行的任務會處於等待狀態，直到前面任務執行完成，才會往後執行。 小知識 因為 JS 設計 Bug 的關係， typeof null 回傳結果是“obejct” ，而非 null 。 了解更多 MDN－ReferenceError: “x” is not defined：了解 not defined 的意義。 MDN－undefined：了解 undefined 的意義。 tim80411－行程(Process)、執行緒(thread)傻傻分不清楚(中)-執行緒管理：了解行程與執行緒的關係。 #7 基本型別：布林值、null、undefined 與 symbol：回顧 null 的型別判斷 Bug。 "},{"title":"#91 作用域與範圍鍊","date":"2024-05-02T16:00:00.000Z","url":"/javascript/20240503/3963825218/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"作用域是變數的有效範圍，瀏覽器會隨著範圍鍊尋找可取用的變數。 快速了解之前介紹過：變數的有效範圍被稱為「作用域」，實際上，作用域還可以細分成靜態與動態兩種。 語法作用域JS 中的「Scope」可稱為作用域、範疇、有效範圍、存在範圍，意思是：變數可被取用（accessibility）或可被看到（visibility）的有效範圍。作用域分為「靜態作用域」與「動態作用域」，其會影響變數的賦值方式，並牽涉到直譯式語言的編譯及運行流程。兩種作用域的區分為： 靜態作用域：變數的作用域在語法解析時，就已經確定作用域，且不會改變。 動態作用域：變數的作用域在函式調用時才決定。JS 採用又被稱為「語法作用域」（lexical scope）的靜態作用域，原始碼寫好時，作用域就已經被確定，且不會再改變。 範圍鍊範圍鍊（Scope Chain）指「當函式內沒有需要的變數時，向外尋找該變數」的過程。範圍鍊是依據函式文法本身來決定，與執行環境無關。當作用域內需要某個變數但在該範圍內找不到時，瀏覽器會向外一層層查找，在全域環境頁找不到時，會回傳 Uncaught ReferenceError: xxx is not defined 的錯誤訊息。 在上述程式碼中，無論是 fn1 或 fn2 ，其範圍鍊都指向全域。 fn1 的回傳結果會是 1 ，因為對 fn1 函式來說，它沒有 value 這個變數，只能往外部環境尋找，而 fn1 的外部環境是全域執行環境，不是 fn2 ，所以最終取得的值是全域的 value = 1 。 了解更多 itsems－Javascript 的作用域 (Scope) 與範圍鏈 (Scope Chain)：深入了解作用域與範圍鍊的概念。 #31 變數的有效範圍：回顧作用域的概念。 "},{"title":"#90 JS 執行環境","date":"2024-05-01T16:00:00.000Z","url":"/javascript/20240502/453057554/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"所有程式碼都必須在執行環境中運作，執行環境相互堆疊後，會形成「執行堆疊」。 快速了解所有程式碼都必須在執行環境（Execution Context）中執行。當 JS 需要執行多件事項時，這些事件會「執行堆疊」，遵守「後進先出」的原則，一件、一件完成。 執行環境執行環境可以分為「全域執行環境」與「函式執行環境」。 全域執行環境：全域環境在瀏覽器或 node.js 開啟後，執行環境會自動產生變數，也會產生 this ，但 this 會隨著執行環境而不同。 函式執行環境：JS 函式的作用域在該函式內部。當一個函式執行時，會產生屬於自己的執行環境，該環境會有限制作用域的功用，且有自己的 this 。 執行堆疊JS 是一種「單執行緒」的程式語言，即一次只能做一件事，如果有太多事情要處理，JS 會將這些事情排隊堆疊，在一件件完成。以下列程式碼為例： 這段程式碼執行堆疊的流程為： 瀏覽器先建立全域執行環境。 建立 first() 執行環境，執行 first() 函式內容，全域執行環境暫停。 建立 second() 執行環境，執行 second() 函式內容， first() 函式執行環境暫停。 second() 函式執行完成，跳出堆疊， first() 函式執行環境繼續。 first() 函式執行完成，跳出堆疊，全域執行環境繼續。 回收機制在函式執行環境中，會創造屬於自己的記憶體空間。而回收機制的目的是追蹤記憶體分配的使用情況，以便自動釋放一個不再使用的記憶體空間，歸還給系統。回收機制的演算法會將「一個不再被任何物件參考的物件」，視為可被回收的記憶體垃圾。因此，若某函式沒有被任何物件參考，其離開執行環境的同時，也會將佔用的記憶體空間釋放出來。 小知識 在全域執行環境下，瀏覽器會產生 window 變數，Node.js 則產生 global 變數。 執行環境的堆疊與「函式宣告順序」無關，而是與「呼叫順序」有關聯。 了解更多 MDN－this：預習 this 的概念。 Coding Monster－秒懂！JavaScript 執行環境與堆疊：了解 JS 執行環境。 items－Javascript 的執行環境 (Execution context) 與堆疊 (Stack)：深入了解 JS 執行環境與堆疊。 MDN－Memory Management：了解記憶體管理的概念。 #24 變數儲存模型：回顧記憶體存放的概念。 "},{"title":"#89 JS 運作方式","date":"2024-04-30T16:00:00.000Z","url":"/javascript/20240501/712895601/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"JS 要透過直譯器編譯後，才生成執行環境看得懂的程式碼。 快速了解我們之前提過：JS 是一種直譯式語言。這代表「JS 無法直接被瀏覽器或電腦給閱讀，要經過編譯（Compile）才能運行這段程式碼」。 JS 如何運作直譯式語言會透過「直譯器」生成電腦看得懂的代碼，並將錯誤直接反映在執行環境中，以 JS 為例，錯誤會直接反映在瀏覽器的主控台（console）上。JS 直譯器轉換時，會先將語法基本單元化（Tokenizing），再解析成抽象結構樹（AST），最後生成代碼： 語法基本單元化（Tokenizing）會將原始碼拆解成一個一個小單元。在此階段，直譯器僅僅只是解析字詞而已，還無法判斷每個小單元的作用。 抽象結構樹（AST，Abstract Syntax Tree）會把前一階段解析的 token 轉換成其被賦予的意義。 直到最後生成代碼，程式碼才會運行。 小知識 瀏覽器、Node.js 等環境的代碼生成過程不盡相同。 了解更多 Esprima：可以觀察直譯器轉換過程的小工具。 CHEN－語法作用域 lexical scope：了解語法作用域的意義。 #1 JS 是什麼？：回顧 JS 是一種什麼樣的程式語言。 "},{"title":"#88 陣列處理方法：map、filter、find、findIndex","date":"2024-01-19T16:00:00.000Z","url":"/javascript/20240120/1550320910/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"使用 map 、 filter 、 find 等進階的陣列處理方法，可以提升開發效率。 快速了解除了前面介紹過的 forEach ，還有許多種陣列處理方法，例如： map 、 filter 、 find 、 findIndex 等。除了 forEach ，其他所有陣列方法都會回傳值。 map map() 方法可以把原有的陣列「映射」到另一個新的陣列，並回傳新的陣列內容。 filter filter() 可以搜尋符合條件的資料，會回傳一個陣列。 find和 filter() 類似， find() 也可以用來搜尋符合條件者，但其只會回傳第一個 true 的值。 findIndex findIndex() 的使用目標也和上述兩者類似，但其回傳的資料會是「索引」，而非值。若無符合的對象，則回傳 -1 。 小知識 除了上述介紹的陣列使用方法，還有 every()、some()、each() 等常見的使用方式。 了解更多 MDN－map：了解 map 的使用方式。 MDN－filter：了解 filter 的使用方式。 MDN－find：了解 find 的使用方式。 MDN－findIndex：了解 findIndex 的使用方式。 卡斯柏－JavaScript 陣列處理方法：了解更多陣列處理方法。 "},{"title":"#87 陣列處理方法：forEach","date":"2024-01-18T16:00:00.000Z","url":"/javascript/20240119/871183559/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"forEach 可達成多種目標，適合在「處理大筆資料」時使用。 快速了解處理大筆資料時，使用陣列處理方法能夠有效提升工作效率。例如： forEach 可以取代 for 迴圈、計算陣列數字累加、讀取字串或物件等不同型別的資料，還可以搭配 if 條件判斷使用。 forEach 結構forEach 的函式結構為 function(item, index, array) ，第一個參數是「當前元素的值」、第二個參數是「當前元素是陣列第幾筆資料」、第三個參數是「當前元素的資料」。特別注意！ forEach 不會回傳值。 範例：forEach 與 for 迴圈當有一個陣列的內容需要依序取值時，通常會使用 for 迴圈的方式，將值一一取出。 學會 forEach 後，可以透過更簡潔的程式碼做到一樣的效果。 必須注意的是， forEach 並沒有像 for 迴圈一樣的中斷方式，故無法被中途停止運行。 了解更多 MDN－forEach：了解 forEach 的使用方式。 卡斯柏－for 迴圈與 forEach 有什麼不同：比較 for 和 forEach 的差異。 "},{"title":"#86 axios","date":"2024-01-17T16:00:00.000Z","url":"/javascript/20240118/2717124241/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"axios 等待伺服器回傳資料時，程式碼會繼續往下執行。 快速了解axios 參數 以上述程式碼為例，首先使用 get 進行網路請求並在參數帶入網址，當伺服器回傳時，會觸發 then 裡面的函式，函式執行後， response 會獲得回傳結果。函式本身預設不執行，只是先被註冊好而已，直到資料回傳時才會啟動。換句話說， then 函式要在「伺服器回傳資料後」才會觸發。另外， response 回傳結果會被自動整理成一個 response 物件，可以透過點記法 . 取得物件內部的屬性資料，例如： .data 可以取得 JSON 檔案中的資料、 .status 可以取得狀態碼的值。 axios 非同步 上述程式碼中，axios 發出網路請求並等待伺服器回傳資料的期間，會執行「非同步的 JS」——即伺服器尚未回傳資料時，程式碼會繼續往下執行，當伺服器回傳時再自動執行內部函式。因此，在該範例中， console.log 的執行順序會是：3、1、2。當 axios 向 xxx.json 檔案發出網路請求時，程式碼會自動往下執行，故會先印出 3 的結果：空陣列 [] ；當伺服器回傳時，在印出 2 的結果：字串 &quot;資料回傳&quot; ；最後，再印出 renderData() 函式的結果。備註：此案例中，最終的印出值是將結果渲染至頁面上。 axios 的 POST 請求除了 GET 請求，axios 也能發送 POST 請求。 上述程式碼代表：axios 發送 POST 請求，將使用者資料傳入伺服器中，如果請求成功則回傳 .then 後的函式結果；如果請求失敗則回傳 .catch 後的函式結果。發出 POST 網路請求後，會回傳夾帶 header 和 data 的資訊，裡面的資料格式（Content-type）包含以下幾種的內容： application&#x2F;x-www-form-urlencoded：發送格式，代表 form 表單發送網路請求。 application&#x2F;json：包裝格式，代表透過 json 格式編譯。 multipart&#x2F;form-data：傳送檔案的格式，例如：圖片、影片或檔案格式。 text&#x2F;plain：純文本格式。 小知識 axios 是一款 JS 套件，可透過官方文檔了解載入方式。 了解更多 GitHub－axios：axios 官方文檔。 "},{"title":"#85 Ajax：處理方式","date":"2024-01-16T16:00:00.000Z","url":"/javascript/20240117/2744536984/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"XMLHttpRequest、Fetch、axios 都是 Ajax 的處理方式。 快速了解一般來說，Ajax 的處理方式有三種： XMLHttpRequest。 Fetch。 axios。前兩者是原生 JS 寫法，最後的 axios 則是需要額外安裝的 JS 套件。 XMLHttpRequest最早期的 Ajax 會使用 XMLHttpRequest 物件（簡稱「XHR」）實作非同步請求，例如以下範例： 在上述程式碼中，為了送出 HTTP 請求，需要先建立一個 XMLHttpRequest 物件，並使用 .open() 開啟一個 URL，最後再用 .send() 發出 request。因為使用 XHR 步驟繁多、較麻煩，實務上很少直接使用原生的 XMLHttpRequest。通常會透過 Fetch、axios 等方法取代。 Fetch原生 JS 還有另一個方法可以處理 Ajax：Fetch API。 使用 Fetch API 的方法會需要「先把回傳的檔案轉檔成 JSON 格式」，再執行後續程式碼。 axiosaxios 是一種 JS 套件，較上述兩者語法精簡、可以透過 node.js 整合後端且受到多種瀏覽器支援。 上述程式碼中，axios 會藉由 get 向目標檔案取得資訊。 小知識 事實上，axios 還是透過 XMLHttpRequest 的方式實作 Ajax。 了解更多 MDN－XMLHttpRequest：了解 XMLHttpRequest 的處理方式。 MDN－Fetch：了解 Fetch 的處理方式。 oxxo－JavaScript Fetch API 使用教學：觀看更多 Fetch 的使用範例。 Alysa Chen－axios基本語法與練習(GET、POST請求)：了解 axios 的處理方式。 GitHub－axios：axios 官方文檔。 "},{"title":"#84 Ajax：同步與非同步","date":"2024-01-15T16:00:00.000Z","url":"/javascript/20240116/3831438034/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"同步的 JS 一次只能做一件事；非同步的 JS 則可以在同時做多件事。 快速了解在了解「非同步」的概念前，先解釋什麼是「同步 JS」。 同步的 JS同步 JS（Synchronous JavaScript）指：用戶端對伺服器端送出 request ，且在收到伺服器端的 response 之後才會繼續下一步的動作，伺服器端在同一時間只能做一件事件，等待的期間無法處理其他事情。簡單來說，同步的 JS 是「一次只做一件事」。若程式都是同步執行的話，會導致網頁的阻塞（Blocking）現象，使得網頁看似當掉、沒有回應，實際上是因為上一件事還沒有完成，所以下一件事情等著尚未執行。 非同步的 JS非同步 JS（Asynchronous JavaScript）則是指：用戶端向伺服器端送出 request 之後，不需要等待結果，仍可以持續處理其他事情，甚至繼續送出其他 request。Response 回傳後，就被融合進當下頁面或應用中。簡單來說，非同步 JS 是「同時可以做很多件事情」。非同步 JS 有兩種回呼方式：較舊的 callback function 與較新的 promise 。如今，callback 已較少被使用。 了解更多 MDN－非同步的 JS：了解 JS 同步與非同步的意義。 "},{"title":"#83 Ajax","date":"2024-01-14T16:00:00.000Z","url":"/javascript/20240115/2393430440/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"Ajax 使瀏覽器不需要重新讀取整個網頁，而讓程式更快回應使用者的操作。 快速了解一般來說，有兩種傳送資料的方式：第一種是透過 form 表單；第二種則是 Ajax。實際上，前者的傳送方式和 JS 無關，而是透過瀏覽器進行 request、response；後者則是透過 JS 與伺服器交換資料。 Ajax 的特性Ajax 的全名是「Asynchronous JavaScript and XML」，其意義為： Asynchronous：非同步。 JavaScript：使用的程式語言。 XML：Client 與 Server 交換資料用的資料與方法，近年由於 JSON 等格式的流行，使用 Ajax 處理的資料並不限於 XML。Ajax 並非單一技術，而是一套綜合性的瀏覽器端網頁開發技術。 Ajax 的優點Ajax 可以優化網站性能，並改善使用者體驗。具體來說，有以下兩個優點： 使用 Ajax 實現動態載入：使用 Ajax 可以「動態載入」，只更新頁面上的某些部分，而非整個頁面。有別於過去要切換不同頁時，還需要等瀏覽器重新渲染整個頁面的情況。 使用 Ajax 實現無刷新更新：使用 Ajax 可以「無刷新更新」，即在不重新載入頁面的情況下將數據發送到伺服器，並根據伺服器的回應更新頁面。不像傳統的表單提交，需要瀏覽器重新載入頁面，影響用戶體驗。 常見的 Ajax 框架 jQuery：最知名且最廣泛使用的 JS 函式庫之一，提供了強大的 Ajax 功能，讓開發者能夠用簡潔語法進行非同步的 HTTP 請求。 Axios：這是一個基於 Promise 的 HTTP 客戶端，用於瀏覽器和 node.js。支援多種瀏覽器並提供了許多實用的功能，如攔截請求和回應、取消請求、轉換 JSON 數據等。 Fetch API：這是瀏覽器原生提供的一個用於數據取得的介面，基於 Promise 設計。是 Ajax 的一種現代化替代方案。 小知識 Ajax 之所以開始受到開發者歡迎，是因為 Google 在 2005 年推出 Gmail 服務時採用此技術大獲成功而知名。 了解更多 MDN－Ajax：了解 Ajax 的意義及學習範例。 ALPHAcamp－什麼是 Ajax？ 搞懂非同步請求 (Async request) 概念：了解 Ajax 的運作方式。 余小魚－form表單介紹 表單結構 表單中的GET 與 POST區別：了解 form 表單的運作方式。 "},{"title":"#82 RESTful API","date":"2024-01-13T16:00:00.000Z","url":"/javascript/20240114/3768071640/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"RESTful API 是一種「語意化且寫法一致」的程式設計風格。 快速了解REST（Representational State Transfer），被譯為「表現層狀態轉換」。是一種程式設計風格，而非標準，以語意化且更為嚴謹的方式描述 API，以此風格設計的架構被稱為「RESTful」。 RESTful API 的特性RESTful API 具有靈活、可擴展且高度獨立的優點，而受到開發者歡迎。且擁有以下幾種特性： 統一介面：API 的設計要盡可能簡單且一致。 無狀態：每一個請求都是獨立的，服務器不會儲存任何請求的狀態。 分層系統：可以使用代理伺服器進行轉發，或提供安全性控制等。 可緩存：響應中的資料能夠被客戶端緩存，提高性能。 隨需編碼：伺服器可透過將程式碼傳輸至用戶端，以臨時擴展或自訂用戶端功能。 RESTful API 運作流程RESTful API 的呼叫流程： 用戶端按照 API 文件，以格式化方式向伺服器端傳送請求。 伺服器端對用戶端進行身份驗證，並確認用戶端有權發出請求。 伺服器端接收請求，並在內部處理。 伺服器端向用戶端傳送回應，該回應包含用戶端請求的任何資訊。 RESTful API 範例RESTful 風格的網址設計強調從路由結構就能看出要對什麼資料、進行什麼操作。一般的 API 可能會長這樣： RESTful API 則會長這樣： 透過把「動作」藏在 HTTP method 裡面，而有唯一的 URL（ /users ）表示資源位置，藉此統一 API 接口。 了解更多 AWS－什麼是 RESTful API？：深入了解 RESTful API 的使用方式。 ALPHAcamp－什麼是REST? 認識 RESTful API 路由語義化設計風格：了解 RESTful API 的意義。 itsems－API 是什麼? RESTful API 又是什麼?：了解 API 和 RESTful API 的差異。 "},{"title":"#81 API","date":"2024-01-12T16:00:00.000Z","url":"/javascript/20240113/1937769504/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"「串 API」是一種雙方進行資料交換的行為。 快速了解API 是 Application Programming Interface 的縮寫，被譯為「應用程式介面」。是應用程式和應用程式之間溝通、交換資料的管道。 介面「介面」是兩個主體溝通的交接點，例如：人可以透過操作咖啡機的面板，和咖啡機溝通使其啟動製作程序。API 是應用程式、裝置之間資料的交換，但不一定要透過網路才能有 API，例如： 軟硬體廠商的 API：USB 與 電腦交換資料。 作業系統裡的 API：讀取、傳輸及寫入等等電腦上的操作。 Web APIWeb API 是基於 http 協定下運作的 API，代表用戶端和伺服器端會透過網路進行資料交換。身為網路開發者，可能會同時作為用戶端與伺服器端存在： 用戶端：串接他人開發的 Web API。 伺服器端：開發 Web API 給他人使用。以下介紹幾種 Web API 的案例： 會員登入系統：社群連結註冊登入（例如：設置 FB 或 Google 登入按鈕）。 社群嵌入：分享、留言版、按讚按鈕、影音（例如：Facebook Graphic）。 資料嵌入：Yahoo 氣象、Google 地圖、Tweet timelines。 假圖 API：隨機產生出圖片。 小知識 使用 API 的過程時，你不需要知道其內部程式運作的邏輯或演算法，你只要告訴 API 它需要知道的事，它就會把你想知道的結果帶來給你。 了解更多 Huli－從拉麵店的販賣機理解什麼是 API：透過生活案例了解 API。 Frankie－API 到底是什麼？ 用白話文帶你認識：白話介紹 API 是什麼。 ALPHAcamp－認識 API 與 Web API ，實用的 API 工具：了解 API 的使用方式。 "},{"title":"#80 HTTP 資料格式","date":"2024-01-11T16:00:00.000Z","url":"/javascript/20240112/3194480579/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"伺服器端會以 XML、JSON 等資料格式回應瀏覽器請求。 快速了解當瀏覽器發送請求時，伺服器端會以 XML、JSON 等資料格式回應。 XMLXML（Extensible Markup Language），又稱為「可延伸標記式語言」。和 HTML 一樣屬於標記語言（Markup Language），會使用「前後標籤」將內容包覆起來。缺點是檔案較大、不易閱讀且處理較花時間，因此現代開發較少使用。 JSONJSON（JavaScript Object Notation），又稱為「JavaScript 物件表示法」。格式容易理解，且相容性高，許多程式均支援讀取或修改，為現代最普遍、常用的資料格式。JSON 會把所有的資料包在一個「物件」內傳遞，因此，撰寫時會使用一對大括號 &#123;&#125; 包住所有內容，欄位則由雙引號 &quot;&quot; 包覆再由冒號 : 連接，每一項欄位則由逗號 , 隔開。 使用 JSON 時需注意以下幾點： 回傳值的型態是「字串」。 支援許多資料格式：[array]、&#123;object&#125; 等；但值不能放函式。 JSON 格式字串不能使用註解。 了解更多 AWS－JSON 與 XML 之間有何區別？：深入了解 XML 與 JSON 的差異。 Johnliutw－基本資料格式: XML + JSON：了解更多 XML 與 JSON 的使用範例。 AppleBOY－你不可不知的 JSON 基本介紹：深入了解 JSON 的使用方式。 "},{"title":"#79  HTTP 狀態碼","date":"2024-01-10T16:00:00.000Z","url":"/javascript/20240111/284833906/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"HTTP 狀態碼代表伺服器端對「用戶端請求」的回應。 快速了解HTTP 狀態碼（HTTP Status Code）是伺服器對於「瀏覽器的請求」所給出的回應，瀏覽器每次發送請求時，伺服器都會用一組三位數的代碼回應該請求，每一組代碼都代表不一樣的狀態。 狀態碼整理依據狀態碼的數值範圍可以區分為以下五類： 100～199：資訊回應。 200～299：成功回應。 300～399：重新導向。 400～499：用戶端錯誤。 500～599：伺服器端錯誤。 常見狀態碼 200 OK ：請求成功。 204 No Content ：伺服器成功處理了請求，沒有返回任何內容。 301 Moved Permanently ：被請求的資源已永久移動到新位置。 302 Found ：要求客戶端執行臨時重新導向。 400 Bad Request ：請求語法錯誤、資源太大、請求訊息無效等用戶端錯誤。 404 Not Found ：找不到資源，請求失敗。 500 Internal Server Error ：伺服器出錯。 503 Service Unavailable ：由於臨時的伺服器維護或者過載，伺服器當前無法處理請求。 小知識 可以在 Chrome 開發者工具的「網路」（Network）選單觀察到每個請求資源的 HTTP 狀態碼。 較少使用 100～199 的狀態碼。 了解更多 維基百科－HTTP 狀態碼：了解更多 HTTP 狀態碼的意義。 "},{"title":"#78 HTTP 請求方法","date":"2024-01-09T16:00:00.000Z","url":"/javascript/20240110/842599140/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"用戶端會依據 HTTP 請求方法向伺服器端溝通。 快速了解HTTP 定義了一組能以不同方式操作指定資源的請求方法（request methods），讓伺服器端能夠清楚辨識 request 的目的。 HTTP 請求方法HTTP 總共有九種請求方法： 請求方法 說明 GET 只應用於取得資料。 HEAD 與 GET 方法相同的回應，但只獲取回應的 header，而沒有 body。 POST 用於提交指定資源的實體，通常會改變伺服器的狀態。 PUT 取代原本的整個 request。和 PATCH 類似。 DELETE 刪除指定資源。 CONNECT 會和指定資源標明的伺服器之間，建立隧道（tunnel）。 OPTIONS 會回傳指定資源其支援哪些請求方法。 TRACE 會與指定資源標明的伺服器之間，執行迴路返回測試（loop-back test）。 PATCH 修改指定資源的部分 request。 CRUD 原則常用的幾個動作分別為： GET &#x2F; POST &#x2F; PUT &#x2F; DELETE，正好對應到資料庫基本操作：CRUD 增刪查改： 請求方法 操作方式 說明 POST Create 新增、建立。 GET Read 查詢、讀取。 PUT Update 更新。 DELETE Delete 刪除。 GET &amp; POST 請求的區別 GET 和 POST 兩種是最常使用的 HTTP 請求方法，兩者最直觀的區別是「資料傳遞方式」與「安全性」。 GET ：向指定的資源要求資料，類似於查詢操作。 資料傳遞方式：將引數由 URL 帶至伺服器端。 安全性：較 POST 不安全，因為傳遞的引數會在 URL 上顯示。 例如：讀取連結或圖片。 POST ：將要處理的資料提交給指定的資源，類似於更新操作。 資料傳遞方式：將引數放在 request body 中傳遞。 安全性：較 GET 安全，適合用於隱密性較高的資料。 例如：會員登入系統。 小知識 HEAD 較少使用，通常應用在只想知道 response 資訊時。 了解更多 MDN－HTTP 請求方法：了解 HTTP 請求方法。 維基百科－增刪查改：了解 CRUD 的意義。 "},{"title":"#77 HTTP","date":"2024-01-08T16:00:00.000Z","url":"/javascript/20240109/654837259/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"HTTP 是一種使「瀏覽器和伺服器進行溝通」的網路協定。 快速了解HTTP（HyperText Transfer Protocol）是一種網路通訊協定，被譯為「超文本傳輸協定」。HTTP 是專門用於瀏覽器與伺服器之間的通訊協定，是全球資訊網的數據通訊基礎。 HTTP 架構HTTP 是一個「用戶端－伺服器端」協定，在協定的兩端分別是用戶端（Client）與伺服器端（Server）。網頁上的資訊，由許多用戶端與伺服器端之間的 request 跟 response 構成。網頁介面呈現過程： 用戶端的瀏覽器傳送 HTTP request 給伺服器端。 伺服器處理過後，再回傳 response 給瀏覽器。 最後由瀏覽器進行 HTML、CSS、JS 解析，並由程式碼渲染成網頁介面。 HTTP 格式伺服器端和用戶端進行請求與回應時，會使用定義明確的請求格式 (request format) 和回應格式 (response format)。請求格式是 HTTP 的請求方法，用戶端需要使用特定的 HTTP 請求方法，向 URL 發出請求。例如： GET 、 HEAD 、 POST 。回應格式則是指伺服器端回應時採用的資料格式，例如：XML、JSON。 小知識 協定（Protocol）制定了規則和標準，讓設備之間不但能認出彼此，也能夠根據不同情境選擇溝通的方式。 了解更多 MDN－HTTP：了解 HTTP 的意義。 AWS－HTTP 與 HTTPS 之間有什麼區別？：延伸了解 HTTP 與 HTTPS 的差異。 ALPHAcamp－認識 API 與 Web API ，實用的 API 工具：了解 HTTP 結構與預習 API 內容。 "},{"title":"#76 事件指派","date":"2024-01-07T16:00:00.000Z","url":"/javascript/20240108/3886780583/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"事件指派會將目標元素的「父級」綁定監聽，再透過冒泡機制傳遞。 快速了解事件指派（Event Delegation）是利用「事件流程」及「單一事件監聽器」來處理多個事件目標。如此不只能提高效率，也能處理動態新增的問題。直接對目標的父元素進行事件監聽，透過冒泡機制，事件會由父元素傳遞到底下的所有子元素，就不需對子元素事件一個個監聽。 事件指派範例 在不透過事件指派的情況下，如果要分別為 myList 的 li 綁定 click 事件，就要利用 for 迴圈一個個綁定。但這時若是要再新增元素到 myList ，會導致「後來新增的 newList 節點不會被註冊 click 事件」的問題。如果每次新增元素後要再重新註冊 addEventListener ，可能會因為重複監聽且忘了移除監聽，而導致記憶體流失（memory leak）的問題。這時，可以藉由事件指派的方法來解決該問題： 上述程式碼中，在取得容器並讓外層 myList 來監聽 click 事件後，使用 if 判斷式判斷目標元素是否為 li ，若是，則執行 console.log 。接著，建立新的 &lt;li&gt; 元素及 textNode 文字節點，再透過 appendChild 將 textNode 加入到 newList 中，最後，透過 appendChild 將 newList 加入至 myList 。把 click 事件改由外層的 myList 監聽，利用事件傳遞的原理，判斷 e.target 是目標節點後，再去執行後續動作。這麼做的好處是：可以輕鬆管理事件，且無需再為後續新增的 newList 額外綁定 click 事件。 小知識 Event Delegation 又翻譯為「事件代理」、「事件委派」。 了解更多 Kuro－隱藏在 “事件” 之中的秘密：本文最主要的參考範例。 Teagan Hsu－DOM事件、Event Delegation：複習 DOM 事件。 "},{"title":"#75 阻擋事件傳遞","date":"2024-01-06T16:00:00.000Z","url":"/javascript/20240107/4041490375/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"e.stopPropagation() 可以阻擋事件傳遞，不論向上或向下。 快速了解前面提過， event.preventDefault() 可以阻擋預設事件，但不會阻止事件向上傳遞。如果想要阻擋事件傳遞，可以利用另一個方法： e.stopPropagation() 。當使用 event.stopPropagation()，事件傳遞就會停在設置的地方： 若在捕獲階段：阻止事件往下傳遞。 若在冒泡階段：阻止事件向上傳遞。 阻擋事件冒泡傳遞範例 e.stopPropagation() 最常見的使用情境是：解決 checkbox 的冒泡問題。 為了增強 checkbox 的易用性，通常會另外加上 label 標籤在為對應的 checkbox 加上 for 屬性。 上述程式碼回傳結果是「把 console.log(&quot;lbl click&quot;); 執行兩次」，因為在 label 標籤包覆 checkbox 的情況下，是透過點擊 label 觸發 click 事件，所以瀏覽器會自動把這個 click 事件傳給 checkbox 。而 checkbox 受事件冒泡影響，會再度把 click 事件傳遞至 label 上，導致 &quot;lbl click&quot; 出現兩次。已知 checkbox 受事件冒泡影響而將事件向上傳遞，如果想要修正 label 的 click 事件觸發兩次的錯誤，可以在 checkbox 的 click 事件加上 e.stopPropagation() 。 小知識 除了 e.stopPropagation() ，還有一種阻擋事件傳遞的方法： e.stopImmediatePropagation() ，其可以阻擋同層的其他事件運作。 在最上層 window 的捕獲階段設定 e.stopPropagation() ，會阻止後續事件傳遞，造成所有好相關事件都失效。 了解更多 Kuro－隱藏在 “事件” 之中的秘密：本文最主要的參考範例。 MDN－stopPropagation：了解 e.stopPropagation 的使用方式。 MDN－stopImmediatePropagation：了解 e.stopImmediatePropagation 的使用方式。 "},{"title":"#74 阻擋預設行為","date":"2024-01-05T16:00:00.000Z","url":"/javascript/20240106/1726339634/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"e.preventDeault() 可以取消事件的預設行為，但不會影響該事件傳遞。 快速了解部分 HTML 元素會有預設行為，例如： &lt;a&gt; 的連結、表單的 &lt;submit&gt; ，如果需要在這些元素上綁定事件，就可能會需要適當地取消它們的預設行為。透過在 Event Handler 加上 e.preventDeault() 的方式即可阻擋預設行為。 阻擋預設行為範例假設要在一個通往 google 的連結 &lt;a&gt; 註冊 click 事件，當點擊該連結時，會印出 Google! 的內容，而不會直接連結到 google 網站。 在 Event Handler 加上 e.preventDeault() 即可阻擋預設行為，讓 &lt;a&gt; 元素的預設行為失效，並讓瀏覽器執行開發者註冊的函式內容。 小知識 event.preventDefault() 不會阻止事件向上傳遞（事件冒泡）。 了解更多 Kuro－隱藏在 “事件” 之中的秘密：本文最主要的參考範例。 MDN－preventDefault：了解 e.preventDeault() 的使用方式。 "},{"title":"#73 事件物件","date":"2024-01-04T16:00:00.000Z","url":"/javascript/20240105/2862496385/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"瀏覽器會主動將「事件物件」的資料傳入事件處理器。 快速了解當監聽事件發生時，瀏覽器會去執行開發者透過 addEventListener() 註冊的 Event Handler（EventListener），即指定的韓式內容。這時，EventListener 會主動建立一個「事件物件」（Event Object），裡面包含所有與該事件有關的屬性，且會以「參數」形式傳給 Event Handler。舉例來說： 上述程式碼的參數 e 即為事件物件。點擊 &lt;button&gt; 後，可以從 console 看到 event 物件提供的屬性，例如： type ：事件名稱。 target ：觸發事件的元素 bubbles ：該事件是否在「冒泡」階段觸發。 pageX &#x2F; pageY ：該事件觸發時，滑鼠座標在網頁的相對位置。 小知識 事件物件是參數，因此可以自定義名義。 可以透過 Chrome 的 console 主控台觀察到事件物件所提供的屬性們。 了解更多 Kuro－隱藏在 “事件” 之中的秘密：本文最主要的參考範例。 MDN－Event：了解更多種事件物件的屬性。 彭彭－Javascript 事件處理 - Event Object 事件物件：了解事件物件的操作方法。 "},{"title":"#72 自定義事件","date":"2024-01-03T16:00:00.000Z","url":"/javascript/20240104/3081470379/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"除了瀏覽器內建事件外，也可以自行建立事件。 快速了解除了瀏覽器提供的標準事件之外，BOM 也提供了讓開發者自行建立事件的方式，此類事件可以用 Event constructor 建立，同樣透過 addEventListener 去監聽，並由 dispatchEvent 來決定觸發的時機。 如果像要在自訂事件內增加更多資料，可以改用 CustomEvent ，在 Event Handler 則透過 event 接收： 了解更多 Kuro－那些你知道與不知道的事件們：本文最主要的參考範例。 MDN－Event reference：參考更多事件。 "},{"title":"#71 特殊事件","date":"2024-01-02T16:00:00.000Z","url":"/javascript/20240103/4271922278/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"組成事件與剪貼簿事件都是常見的特殊事件。 快速了解組成事件組成事件（Composition Event）指 conpositionstart 、 compositionend 及 compositionupdate 這三個事件。透過 Composition Events ，可以觀察使用者在輸入框內開啟輸入法（Input Method Editor, IME）時，組字或選字的狀態。 Composition Events 的三個監聽事件之意義： compositionstart 事件：輸入框內開啟輸入法，且正在拼字時觸發。 compositionupdate 事件：輸入框內開啟輸入法，且正在拼字或選字時更改了內容時觸發。 compositionend 事件：輸入框內開啟輸入法，拼字或選字完成，正要送出至輸入框時觸發。組成事件可以解決一連串和「輸入框」有關的問題，例如： 當要動態監聽輸入框的文字變化時，通常會以 keydown 、 keypress 、 keyup 等鍵盤事件來判斷是否變動，但若是「複製貼上」之類的操作，就無法透過鍵盤事件判斷。 即使是 change 事件，也是在使用者改變內容，且焦點離開輸入框的前一刻才被觸發。 雖然使用 input 事件，其「會在輸入框的內容被改變時即時觸發」的特性，可以解決在 onChange 及鍵盤相關事件功能不足的情況。然而，這會導致新的問題——透過類似 autocomplete （自動完成）的方式給使用者建議時，使用「注音符號」或「拼音文字」給搜尋建議沒有太大意義。這些問題都可以透過 Composition Events 增強輸入框的行為，而得到修正。 剪貼簿事件與剪貼簿操作相關的事件有以下三個： cut 事件：當使用者在網頁上選取某段文字，並進行「剪下」動作時觸發。 copy 事件：當使用者在網頁上選取某段文字，並進行「複製」動作時觸發。 paste 事件：當使用者將剪貼簿的文字貼上時觸發。 了解更多 Kuro－那些你知道與不知道的事件們：本文最主要的參考範例。 Kuro－透過 Composition Events 增強非拉丁語系輸入法對輸入框的支援：了解 Composition Events 的使用方式。 "},{"title":"#70 表單相關事件 ","date":"2024-01-01T16:00:00.000Z","url":"/javascript/20240102/90660923/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"表單事件通常與表單狀態改變有關。 快速了解多數表單相關事件被用來處理表單元素，例如： &lt;input&gt; 、 &lt;select&gt; 、 &lt;textarea&gt; 等。 input 事件：當 input 、 textarea 及帶有 contenteditable 的元素內容被改變時，就會觸發事件。 select 事件：當使用者在 input 、 textarea 元素選取文字時觸發。 change 事件：當 input 、 select 、 textarea 、 radio 、 checkbox 等表單元素被改變時觸發。但與 input 事件不同的是， input 事件會在輸入框輸入內容的當下觸發，而 change 事件則是在目前焦點離開輸入框後才觸發。 submit 事件：當 &lt;form&gt; 被送出時觸發，通常表單驗證都會在這一步處理，若驗證未通過則 return false; 。 reset 事件：當 &lt;form&gt; 被重置時觸發。 focus 事件：當表單元素被聚焦時觸發。 blur 事件：當表單元素失去焦點時觸發。 select 事件補充 input 、 textarea 元素中被選取的文字可以在 event.target 裡的 selectionEnd 、 selectionStart 及 value 的屬性中取得。 了解更多 Kuro－那些你知道與不知道的事件們：本文最主要的參考範例。 "},{"title":"#69 鍵盤相關事件","date":"2023-12-31T16:00:00.000Z","url":"/javascript/20240101/2442920394/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"常見的鍵盤事件可分為「壓下」、「按住」、「放開」三種。 快速了解常見的鍵盤相關事件有以下三種，在多數情況下會將鍵盤事件註冊在 input 等表單輸入框上。 keydown 事件：「壓下」鍵盤按鍵時會觸發 keydown 事件。 keypress 事件：除了Shift、Fn、CapsLock 這三種按鍵外，其他按鍵被按住時會觸發，若按著不放則會連續觸發。 keyup 事件：「放開」鍵盤按鍵時觸發。 事件執行順序如果針對某元素同時綁定上述三個鍵盤事件，其執行順序會是： 小知識 目前已不推薦使用下面推薦文章中的 event.keyCode 屬性，參見文章：MDN－KeyboardEvent.keyCode。 了解更多 Kuro－那些你知道與不知道的事件們：本文最主要的參考範例。 "},{"title":"#68 滑鼠相關事件","date":"2023-12-30T16:00:00.000Z","url":"/javascript/20231231/3660518762/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"滑鼠相關事件觀念不難，卻非常重要，是常見面試考題。 快速了解以下為幾種常見的滑鼠相關事件： mousedown &#x2F; mouseup 事件：此二事件分別會在滑鼠點擊某元素「按下」（mousedown）按鈕，及「放開」（mouseup）按鈕時觸發。 click 事件：當滑鼠「點擊」某元素時觸發。 dbclick 事件：當滑鼠「連點兩次」某元素時觸發。 mouseenter &#x2F; mousemove &#x2F; mouseleave &#x2F; mouseover 事件：這幾個事件要放在一起看 當滑鼠游標移入某元素時，會先觸發 mouseenter &#x2F; mouseover 事件。 滑鼠游標在這個元素內「移動」時，會連續觸發 mousemove 事件。 直到滑鼠游標離開該元素，才觸發 mouseleave 事件。 mouseenter v.s. mouseover mouseenter &#x2F; mouseover 事件雖然都是滑鼠游標移入了某元素時觸發，但兩者最大的不同之處，在於支援事件冒泡與否，以及觸發時間的不同。首先，說明兩者冒泡與否的差異。 先看看為 inner 與 outer 註冊 mouseenter 事件的回傳結果： 再看看註冊 mouseover 事件的回傳結果： mouseover 事件與 mouseenter 的差異在於： mouseover 會將事件冒泡至上層元素當中。換句話說，當 inner 的 mouseover 事件被觸發了，它同時也會將事件傳遞一份到上層元素中，即 outer ，因此 console 會再次印出 &quot;outer&quot; 。接著，說明兩者觸發時間的差異。在下面案例中，同時為 outer 註冊 mouseenter 與 mouseover 事件： 由此可以觀察到 mouseover 的觸發時機早於 mouseenter 。 小知識 與 mouseleave 事件相對應的還有 mouseout 事件，前者無事件冒泡；後者有事件冒泡。 了解更多 Kuro－那些你知道與不知道的事件們：本文最主要的參考範例。 sh1zuku－Mouse Event 小筆記：了解更多滑鼠相關事件。 "},{"title":"#67 網頁介面相關事件","date":"2023-12-29T16:00:00.000Z","url":"/javascript/20231230/4272355166/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"網頁介面相關事件大多數與 BOM 較有關聯。 快速了解介面相關的事件不一定會與使用者對 DOM 的操作有關，反而大多數與 window 物件——即網頁介面相關事件——比較相關。 load 事件：註冊在 window 物件上，指的是網頁資源（包括 CSS、JS、圖片等資源）全數載入完畢後才觸發。若是 img 元素的 load 事件，則表示「該圖片載入完畢後觸發」。 unload 、 beforeunload 事件：與 load 事件相反， unload 與 beforeunload 事件分別會在離開頁面或重新整理時觸發，而 beforeunload 會跳出對話框，詢問使用者是否要離開目前頁面。 error 事件：會在 document 或圖片載入錯誤時觸發。 resize 事件：當瀏覽器或指定元素的「尺寸變更」時觸發。 fullscreenchange 事件：當使用者切換瀏覽器為全螢幕或是還原原視窗時觸發。 scroll 事件：當瀏覽器或指定元素的「捲軸被拉動」時觸發。 DOMContentLoaded 事件：類似 load 事件，但 load 事件是在網頁「所有」資源都已載入完畢後才觸發，而 DOMContentLoaded 事件則是在 DOM 被完整讀取與解析後就會被觸發，不需等待外部資源讀取完成。 error 事件補充由於維護性考量，強烈建議用「非侵入式 JS」註冊大多數事件，只有 error 事件適合以 on-event handler 的寫法處理。 上述程式碼表示：當 image.jpg 圖檔不存在時，馬上就會觸發 error 事件，透過 this.src 將 &lt;img&gt; 的 src 屬性替換成指定的預設圖檔。若是在網頁載入完成後才註冊 error 事件的處理器，只會看到破圖的結果，因為 error 事件不會再次被觸發。 DOMContentLoaded 事件補充如果 &lt;script&gt; 標籤放在 &lt;head&gt;...&lt;/head&gt; 之間，會因為還沒解析到網頁本體，而導致選取不到 DOM 的問題。但如果把 &lt;head&gt; 的程式碼改成 DOMContentLoaded 事件，讓 document 結構已解析完畢再執行內容，就可以排除 &lt;script&gt; 標籤放在 &lt;head&gt;...&lt;/head&gt; 之間抓不到 DOM 的問題。 小知識 為了防止使用者遺失編輯中的資料或遭到詐騙， beforeunload 對話框的文字在 Chrome 51 後就不再提供自訂訊息的功能。 jQuery 中的 $(document).ready(handler) 語法，其作用和 DOMContentLoaded 事件類似。 了解更多 Kuro－那些你知道與不知道的事件們：本文最主要的參考範例。 "},{"title":"#66 非侵入式 JS","date":"2023-12-28T16:00:00.000Z","url":"/javascript/20231229/3684974278/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"非侵入式 JS 讓 HTML 與 JS 能「關注點分離」。 快速了解非侵入式 JS（Unobtrusive JavaScript）是一種將 JS 從 HTML 結構中抽離的設計概念，避免在 HTML 標籤中夾雜一堆類似 onchange 、 onclick 等屬性來註冊 JS 事件，使 HTML 與 JS 能真正做到關注點分離，讓 HTML 專心負責結構與內容，而 JS 則專心負責操作與行為。因此，傳統透過屬性去註冊事件的方式，屬於「侵入式」作法；而當頁面載入到瀏覽器中時，才去相對應地進行事件設定，則是屬於「非侵入式」的 JS 作法。非侵入式 JS 範例： 上述程式碼中， window 的 DOMContentLoaded 事件代表網頁上的 DOM 已解析完畢。 補充說明除了事件之外，非侵入式 JS 的本質其實是在原有基礎上再增加「行為層分離」的概念，這些原則對大規模軟體工程開發非常重要。 了解更多 維基百科－非侵入式JavaScript：了解非侵入式 JS 的概念。 Nissen－前端技術發展史，關注點分離的辯證：了解「關注點分離」的重要性。 #64 事件的註冊綁定：回顧非侵入式 JS 的影響。 "},{"title":"#65 事件監聽","date":"2023-12-27T16:00:00.000Z","url":"/javascript/20231228/626749644/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"使用 addEventListener() 註冊事件監聽的好處：可重複指定多個「處理器」給同一事件。 快速了解前一個章節介紹的 on-event 處理器其對應 function 指「事件處理器」，本節分享的 addEventListener() 則是「事件監聽器」。 addEventListener() 節構 addEventListener() 基本上有三個參數：「事件名稱」、「事件處理器」（事件觸發時執行的 function ）及「一個 Boolean 值」。並由該 Boolean 值決定事件是以「捕獲」或「冒泡」機制執行，若不指定則預設為「冒泡」。使用 addEventListener() 註冊事件的好處是：可以重複指定多個「處理器」給同一元素的同一事件。 解除事件監聽透過 removeEventListener() 可以解除事件註冊。和 addEventListener() 一樣， removeEventListener() 的三個參數分別是「事件名稱」、「事件處理器」以及「捕獲」或「冒泡」的機制。 同時綁定多個處理器的情況需要特別注意：因為 addEventListener() 可以同時針對某事件綁定多個處理器，所以透過 removeEventListener() 解除事件時，第二個參數的處理器必須要與先前在 addEventListener() 綁定的是同一個「實體」。因此，建議將第二個參數先另外宣告，再註冊事件監聽。 option 物件 addEventListener() 的第三個參數用來表示「捕獲」或「冒泡」的機制，除了單一個 Boolean 值，還可以傳入名為 option 的物件。 option 物件有三個屬性可以指定，每一個的值都是 Boolean ： once ：代表該事件只會被觸發一次，結束後就自動解除事件監聽。 passive ：當設定成 true 時，表示該處理器不會呼叫 event.preventDefault() 這個 event 方法。若開發者呼叫 event.preventDefault() ，瀏覽器會直接忽略並在 console 主控台顯示警告訊息。 capture ：與原本用來表示「捕獲」或「冒泡」的機制相同。 小知識 除了 IE，目前多數主流的瀏覽器都支援 option 物件。遇到不支援 option 物件的瀏覽器，會把其視為 true 看待。 了解更多 MDN－addEventListener()：了解 addEventListener() 的使用方式。 MDN－options：了解 option 的結構。 Alex lan－addEventListener的第三個參數：中文版 option 介紹。 "},{"title":"#64 事件的註冊綁定","date":"2023-12-26T16:00:00.000Z","url":"/javascript/20231227/3714111571/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"on-event 處理器可以針對 HTML 屬性與非 HTML 屬性，進行事件綁定。 快速了解針對 HTML 屬性與非 HTML 屬性，有不同的方式可以綁定網頁元素的事件。 on-event 處理器（HTML 屬性）對 HTML 元素來說，只要支援某個「事件」的觸發，就可以透過 on 加上事件名稱的屬性來註冊事件： 以上述程式碼為例，透過 onclick 屬性，可以在 &lt;button&gt; 元素上註冊 click 事件。換句話說，按下 &lt;button&gt; 元素時，會執行 console.log(&quot;HI&quot;); 的程式碼。 on-event 處理器（非 HTML 屬性）在 window 或 document 此類沒有實體元素的情況，可以利用 DOM API 提供的「 on-event 處理器」（on-event handler）來處理事件。 上述程式碼會在 window 觸發 load 事件時執行對應內容。此外，實體元素也可以透過 DOM API 取得 DOM 物件後，再透過 on-event 處理器處理事件。 如果想要解除事件，重新指定 on-event 處理器為 null 即可。 小知識 早期 JS 常用 on-event 處理器的方式綁定 HTML 屬性的事件，在「非侵入式 JS」的理論被提出後，基於程式碼的重複使用性與維護性考量，現在已經不建議用此方式綁定事件。 了解更多 Kuro－事件機制的原理：本文最主要的參考範例。 "},{"title":"#63 事件傳遞","date":"2023-12-25T16:00:00.000Z","url":"/javascript/20231226/236790616/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"事件傳遞的基礎原則：先捕獲再冒泡。 快速了解事件流程有兩種機制，分別是「事件冒泡」與「事件捕獲」。乍看之下，這兩種機制互不相關。但其實，事件會同時依賴這兩種機制，故兩者都會被執行。 事件傳遞機制基本上，DOM 事件傳遞機制可分成三個階段： 捕獲階段（Capturing Phase） 傳遞到元素本身（Target Phase） 冒泡階段（Bubbling Phase）任何事件在傳遞時，都會按照這個順序進行：當觸發底層節點事件的同時，上層所有節點也會被觸發。事件傳遞會遵守兩個原則： 先捕獲，再冒泡。 當事件傳到 target 本身，沒有分捕獲跟冒泡。具體來說，觸發事件時會先進行「捕獲階段」，從最外層的根節點 document 開始往內傳遞到事件目標 target ；接著再進行「冒泡階段」，由下往上回傳。 了解更多 Kuro－事件機制的原理：本文最主要的參考範例。 itsems－Javascript 中的 DOM 事件傳遞機制：捕獲與冒泡：了解完整的事件傳遞過程。 Huli－DOM 的事件傳遞機制：捕獲與冒泡：深入了解事件傳遞過程。 "},{"title":"#62 事件捕獲","date":"2023-12-24T16:00:00.000Z","url":"/javascript/20231225/2256329046/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"事件捕獲機制和「事件冒泡」相反，是由上到下觸發。 快速了解事件捕獲（Event Capturing）與「事件冒泡」機制相反，會「由上到下」傳遞。 事件捕獲範例 點擊 &lt;div&gt;CLICK&lt;/div&gt; 元素後，在「事件捕獲」機制下，觸發事件的順序是： document &lt;html&gt; &lt;body&gt; &lt;div&gt;CLICK&lt;/div&gt; click 事件由上到下依序被觸發。 了解更多 Kuro－事件機制的原理：本文最主要的參考範例。 Event Flow: capture, target and bubbling：事件捕獲示意圖。 "},{"title":"#61 事件冒泡","date":"2023-12-23T16:00:00.000Z","url":"/javascript/20231224/1379383071/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"事件冒泡機制指「由啟動事件逐層向上依序被觸發」。 快速了解事件冒泡（Event Bubbling）指「從啟動事件的元素節點開始，逐層往上傳遞」，直到整個網頁的根節點—— document 為止。 事件冒泡範例 點擊 &lt;div&gt;CLICK&lt;/div&gt; 元素後，在「事件冒泡」機制下，觸發事件的順序是： &lt;div&gt;CLICK&lt;/div&gt; &lt;body&gt; &lt;html&gt; document由 click 事件逐層向上依序被觸發。 了解更多 Kuro－事件機制的原理：本文最主要的參考範例。 Event Flow: capture, target and bubbling：事件冒泡示意圖。 "},{"title":"#60 事件流程","date":"2023-12-22T16:00:00.000Z","url":"/javascript/20231223/2664330907/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"事件流程就是網頁元素接收事件的順序。 快速了解事件流程（Event Flow）指「網頁元素接收事件的順序」。事件流程可以區分成兩種機制： 事件冒泡（Event Bubbling）。 事件捕獲（Event Capturing）。 事件流程範例假設有兩個重疊的 div 元素，外層是 &lt;div id=”outer”&gt; ，而內層是 &lt;div id=&quot;inner&quot;&gt; ： 在不考慮 position: absolute; 的前提下，內層一定在外層裡面，換言之， inner 是 outer 的一部份。因此，當我們點擊 inner 時，是否也代表我們也點擊到 outer ，甚至，代表我們實際上也點擊到整個網頁。這樣「事件先後發生的網頁元素接收事件順序」，就是事件流程。 了解更多 Kuro－事件機制的原理：本文最主要的參考範例。 "},{"title":"#59 事件機制的原理","date":"2023-12-21T16:00:00.000Z","url":"/javascript/20231222/2707769710/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"事件機制原理為「被觸發後執行對應動作」。 快速了解JS 是一種由「事件驅動」（Event-driven）的程式語言，當瀏覽器載入網頁開始讀取後，雖然會馬上讀取 JS 事件相關的程式碼，但必須等到「事件」被觸發後，才會再對應程式碼執行。以「常見的網頁對話框」來說：使用者「點擊按鈕」後，才會啟動「顯示對話框」的功能。上述這樣「點擊按鈕」的過程被稱為「事件」（Event），而負責處理事件的程式——即「顯示對話框」的行為，則被稱為「事件處裡者」（Event Handler）。 了解更多 Kuro－事件機制的原理：本文最主要的參考範例。 "},{"title":"#58 BOM：history","date":"2023-12-20T16:00:00.000Z","url":"/javascript/20231221/520630088/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"history 搭配 SPA 的應用，可以提升使用者體驗並保障安全性。 快速了解 window.history 會記錄使用者在目前瀏覽器視窗上顯示過的頁面，且會把曾經瀏覽過的頁面 URL 放在 history 物件當中。此外，由於隱私考量，BOM 不允許 JS 讀取清單上的詳細網址，所以我們只能取得 history 的 length 屬性，進而得知當下這個瀏覽器曾經切換過幾次頁面。 相關語法除了 length 屬性外， history 物件還提供 back() 、 forward() 及 go() 這三種方法，讓 JS 可以控制網頁的歷史紀錄。 SPA 與錨點當今流行的前端趨勢——SPA（Single Page application，單頁式應用），是一種「在單一頁面上動態更新目前頁面內容」的程式模型。過去，會透過操作 hash 的方式，讓使用者在切換上、下頁的同時瀏覽器不換頁更新。當使用者點擊錨點時，瀏覽器會在 history 增加一筆新紀錄，且不離開目前頁面。此做法的缺點是：網站永遠只有單一網址，且 hash 紀錄可能會大到難以維護。 SPA 與 pushState在 HTML5 的規範中， history 物件新增了 pushState() 用法，可以將狀態與網址同時存入到 history 物件紀錄中，並在使用者切換上、下頁時，將已儲存的狀態還原至頁面中，如此達到在單一頁面中無縫切換的良好體驗。 pushState() 語法為： pushState(state, unused, url); ，第一個參數為儲存的物件；第二個參數代表新頁面的標題；第三個參數則是新頁面的網址。 呼叫 history.pushState() 方法後，瀏覽器會在 history 物件新增一筆紀錄，且儲存當下的 state 。為了安全性考量，防止有心人利用網址替換來進行詐騙， pushState() 第三個參數的網址內容，只能限定在相同網域下或是使用相對網址。 小知識 由於無法取得 URL 的完整歷史清單，所以在實務上 history.go() 不如 back() 或 forward() 實用，因為開發者無法掌握使用者最終會被 history 導致哪一頁。 了解更多 MDN－history：了解 history 的概念。 MDN－pushState：了解 pushState() 的使用方式。 MDN－SPA：了解單頁式應用的意義。 Schaos－為什麼網站要做成 SPA？SSR 的優點是什麼？：學習 SPA 的功能與發展。 "},{"title":"#57 BOM：location","date":"2023-12-19T16:00:00.000Z","url":"/javascript/20231220/1229262100/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"利用 location 可以擷取網址內容並進行換頁。 快速了解 window.location 物件包含了所有與目前頁面網址相關的資訊。 網址列結構從網址列來看，由前到後分別是 protocol 、 host 、 hostname 、 port 、 pathname 、 search 、 hash 及包含整個網址的 href 屬性。 換頁方式利用 JS 更換網址到新頁面有兩種方式： location.href 與 location.replace() ，兩者看似幾乎一樣，但仍有些差異。 location.href 的範例： 透過 location.href 換頁，就像是用滑鼠點擊 &lt;a&gt; 標籤的超連結一樣。瀏覽器會記錄該連結的歷史紀錄，所以可以藉由按下瀏覽器的「上一頁」、「下一頁」來進行來回。且可以使用 document.referrer 查到上一頁的來源網址。 location.replace() 的範例： 若是透過 location.replace() 來換頁，雖然在 document.referrer 同樣可以記錄上一頁的網址，但瀏覽器的歷史紀錄不會留存前一頁的紀錄，故無法透過瀏覽器的「上一頁」、「下一頁」按鈕來回跳頁。 標籤DOM 裡的 &lt;a&gt; 元素也有提供類似 location 的屬性。如果要擷取某個網址的 hostname 、 pathname 、 query string 及 hash 等值，如果透過傳統做法，會使用「正規表示法」（Reglar Expression）擷取該網址的字串並進行解析，但也可以使用更簡潔的方式透過 &lt;a&gt; 標籤解析： 利用 document.createElement 建立 &lt;a&gt; 標籤，再透過 href 屬性將網址傳入 link 後，這個 link 變數也跟 location 物件擁有同樣屬性的結構，因此，可以直接對該變數擷取需要的值。 小知識 可以透過指定 hash 屬性跳到指定錨點。 了解更多 MDN－location：了解 location 的概念，內有範例網址可參考結構。 MDN－Document.referrer：了解 document.referrer 的概念。 Huli－簡易 Regular Expression 入門指南：了解 Reglar Expression 的基礎寫法。 "},{"title":"#56 BOM：window 物件","date":"2023-12-18T16:00:00.000Z","url":"/javascript/20231219/860044878/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"window 物件是 BOM 核心，在每一個頁面中都是獨立存在的。 快速了解BOM 的核心是 window 物件，它只要是作為「全域物件」和「瀏覽器溝通窗口」存在。 BOM 的角色DOM 是開發者用來操作網頁元素的關鍵，BOM 則是扮演 JS 與瀏覽器溝通的窗口。BOM 提供開發者呼叫瀏覽器內建的功能，例如： alert() 對話框、控制上下頁的 history 、負責捲軸功能的 scroll 等。 window 物件BOM 包含了 DOM，JS 會透過瀏覽器提供的 BOM 來存取 document 的 DOM 模型，因此，DOM 的 document.querySelector 實際上是 window.document.querySelector ，而作為全域物件的 window 可以省略不寫。瀏覽器的 JS 會透過一個全域物件來存放所有的全域變數與函式，所有全域變數都會自動成為該全域物件的「屬性」，因此，可以透過 window 物件去存取全域變數。另外，每一個獨立瀏覽器視窗的 window 物件都是彼此獨立的，換句話說，原本的變數、屬性無法在另外一個新開啟的頁面存取。 node.js 的全域物件在 node.js 中也有全域物件的設定，但其與瀏覽器中的 JS 不同。 node.js 的全域物件名稱為 global ，且即使在全域作用範圍下宣告變數，它也不會成為 global 物件下的屬性。 因為「在全域作用範圍下宣告變數不會成為 global 物件屬性」的特性，在 node 環境中執行上述程式碼，只會得到 undefined 的結果。 小知識 通常來說，原本的變數、屬性無法在另外一個新開啟的頁面存取，但 SPA 單頁式應用與 localStorage/cookie 等情況例外。 了解更多 Mike Huang－localStorage 的使用：了解 localStorage 的基礎運用。 #41 BOM：回顧 BOM（瀏覽器物件模型）的內容。 "},{"title":"#55 DOM：標籤屬性","date":"2023-12-17T16:00:00.000Z","url":"/javascript/20231218/1392055196/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"透過 setAttribute 可以為標籤設定屬性。 快速了解DOM 中也有針對標籤屬性的相關語法： setAttribute 。 setAttribute針對指定元素去設定標籤屬性，若屬性已經存在，會更新該值；否則會為指定的名稱和值添加一個新屬性。 setAttribute 的語法為 element.setAttribute(name, value); ，第一個參數為屬性名稱，第二個參數為屬性值。 上述程式碼會把 color: red; 的屬性加入到 &lt;p&gt; 標籤上。 補充用法如果想獲取某個屬性目前的值，可以使用 getAttribute() ；而若想刪除某屬性，則可使用 removeAttribute() 。此外，還可以透過 hasAttribute() 檢查指定屬性是否存在。 了解更多 MDN－setAttribute：了解 setAttribute 的概念。 MDN－getAttribute：了解 getAttribute 的概念。 "},{"title":"#54 DOM：innerHTML","date":"2023-12-16T16:00:00.000Z","url":"/javascript/20231217/3149519580/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"innerHTML 能夠將字串傳進 HTML 並進行渲染，但安全性較低。 快速了解前面介紹過，可以利用 document.createElement() 的方式建立新元素。但此方法還需要搭配 appendChild() 、 insertBefore() 等語法將內容顯示在網頁中。這時，如果透過 innerHTML 則可以讓我們用更簡潔的程式碼來使用 JS 操作 HTML。 innerHTML innerHTML 可以較方便地插入、替換 HTML 內容，但仍有其限制：插入內容必須是字串型別。嚴格來說， innerHTML 的插入內容必須是包含 HTML 標籤的字串。另外，需要特別注意的是：若插入內容包含 class 屬性，要小心包圍 class 值的單雙引號不要跟外面包起來的引號重複，否則解譯器會不知道這一行程式碼的終點為何。 innerHTML 與 createElement 的比較innerHTML： 不需要搭配其他語法使用。 組完字串後，傳進 HTML 裡進行渲染。 安全性低，可能會成為網路攻擊的媒介，而導致安全問題。 效能較高。createElement： 需搭配 appendChild() 使用，在 HTML 父元素下新增子元素。 以建立一個新的 DOM 節點來處理。 安全性高。 效能較低。 重點整理 使用方式 優點 缺點 innerHTML 以字串渲染 效能高 安全性低 createElement 以 DOM 節點處理 安全性高 效能低 小知識 如果需要插入一段 HTML，而非替代它的內容，建議使用 insertAdjacentHTML() 方法。 基於資安風險問題，插入純文字內容時，建議使用 Node.textContent 方法。 了解更多 MDN－innerHTML：了解 innerHTML 的使用方式。 MDN－insertAdjacentHTML：了解 insertAdjacentHTML() 的使用方式。 Tim－使用 JavaScript 插入 innerHTML：觀看更多 innerHTML 範例。 Greta Ma－如何用 JS 新增 HTML 內容：了解 innerHTML 與 createElement 的差異。 #49 DOM：節點新增：回顧 createElement 新增節點的方式。 "},{"title":"#53 DOM：文字節點","date":"2023-12-15T16:00:00.000Z","url":"/javascript/20231216/434066502/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"textContent 回傳純文字，而 innerText 則會回傳實際呈現在頁面上的樣子。 快速了解透過 textContent 與 innerText 可以選取並新增、修改、刪除文字節點。這兩者用途很相似，但仍有所區別。 textContent textContent 會獲取節點中所有元素的內容，包括 &lt;script&gt; 與 &lt;style&gt; 元素。且回傳節點中的每一個元素，故隱藏內容仍會在畫面中顯示，例如：下面案例的 &lt;span style=&quot;display:none;&quot;&gt;!!!&lt;/span&gt; 。 innerText innerText 會獲取「渲染後的文字內容」（rendered text content），即被 CSS 調整過樣式的文字。受 CSS 樣式影響，只會展示「實際所見的內容」，不會回傳隱藏元素的內容，且會觸發回流。 了解更多 MDN－innerText：了解 innerText 的概念。 MDN－textContent：了解 textContent 的概念。 Eason Lin－innerText 與 textContent：了解 innerText 與 textContent 的差異。 "},{"title":"#52 DOM：節點樣式","date":"2023-12-14T16:00:00.000Z","url":"/javascript/20231215/2022605776/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"可以透過 JS 修改 CSS 樣式，但盡量不要這麼做。 快速了解JS 有以下幾種常見的修改 CSS 樣式方法： 直接修改元素的 style 屬性。 透過修改 className 屬性或 classList 提供的 api 來修改元素的 class 屬性。 利用 JS 直接寫入 CSS 樣式。 修改元素的 style 屬性JS 修改元素的 style 屬性是對「行內樣式」進行修改。是透過 DOM api 修改元素的行內樣式，因此，樣式優先級會高過多數的其他樣式寫法（ !important 除外）。 特別注意！JS 的變數名稱及物件屬性名不允許使用 - 符號，所以在使用時要改為「駝峰式」寫法。 修改元素的 class 屬性由於 class 是保留的關鍵字，所以 JS 實際上是透過 className 來操作網頁標籤內的 class 屬性。 但是，當有多組 class 時，直接修改 className 內的值，不會保留原本的 class 屬性，原本的 class 會被覆蓋。為了解決這個問題， DOM api 新增了一組 classList 屬性來取代原本的 className ，讓原本的 class 屬性被保留。元素裡的 classList 屬性與 className 不同的是：它是一個「唯獨」的屬性。換言之，不能直接透過變更這個屬性來修改 DOM 的 class ，而是要利用 classList.add() 與 classList.remove() 修改它。 利用 JS 直接寫入 CSS 樣式常見的做法有兩種： 利用 document.write 在 &lt;head&gt; 寫入 CSS。 利用 document.createElement 新增 link 標籤。 透過這種方法的好處是：可以加入條件判斷來決定是否寫入 CSS 樣式。 小知識 通常來說，該交給 CSS 處理的樣式，就盡量不要用 JS 處理。 CSS 分為行內樣式（inline-style）與外部樣式（external），前者是直接在 HTML 元素的 style 屬性進行設定；後者則會透過 &lt;link&gt; 連接外部 CSS 檔案。 事實上，直接利用 JS 直接寫入 CSS 樣式是比較少見的做法，但在某些情況下確實是個實用的方式。 了解更多 Greta Ma－如何用 JS 更改 HTML &amp; CSS 屬性：了解動態更改元素樣式的方法。 "},{"title":"#51 DOM：節點刪除","date":"2023-12-13T16:00:00.000Z","url":"/javascript/20231214/2687438073/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"removeChild() 可以移除單一節點； innerHTML 則可以清空所有內容。 快速了解DOM 除了新增、修改等功能，還可以刪除節點。透過 removeChild() 方法，可以將指定的 childNode 子節點刪除。 上述程式碼在取得容器後，會先取得 &lt;li&gt;Item 02&lt;/li&gt; 元素，再將 myList 下的 removeNode 節點刪除。 清空元素的內容 removeChild() 只能移除單一的網頁節點，如果需要將某個元素的內容清空，可以使用 innerHTML ，就可以輕鬆將 myList 裡面的 HTML 一口氣清空。 了解更多 Kuro－DOM Node 的建立、刪除與修改：本文最主要的參考範例。 "},{"title":"#50 DOM：節點修改","date":"2023-12-12T16:00:00.000Z","url":"/javascript/20231213/1334002290/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"透過節點修改，可以將新增的 DOM 節點加入到指定位置。 快速了解前面提過：新增的元素或節點需要藉由 appendChild() 、 insertBefore() 或 replaceChild() 等方法加入到指定位置，才能顯示。這些方法可以將新建立的 DOM 節點置入到指定位置。 Node.appendChild(childNode)透過 appendChild() 可以將指定的 childNode 節點，加入到父容器節點的末端。 上述程式碼在取得容器後，會依序建立 &lt;li&gt; 元素與文字節點，再透過 appendChild() 將 textNode 加入到 newList ，最後，把 newList 置於 myList 的最後方，即可成功顯示。 Node.insertBefore(newNode, refNode)透過 insertBefore() 方法可以將新節點 newNode 插入到指定的 refNode 節點前面。 上述程式碼在取得容器後，會取得 &lt;li&gt;Item 02&lt;/li&gt; 元素並建立 li 元素和文字節點，再將 newNode 插入到 refNode 前方。 Node.replaceChild(newChildNode, oldChildNode)透過 Node.replaceChild() 可以將原本的 oldChildNode 替換成指定的 newChildNode 。 上述程式碼在取得容器後，會取得 &lt;li&gt;Item 02&lt;/li&gt; 元素並建立 li 元素和文字節點，再將原有的 oldNode 替換成新節點的 newNode 。 了解更多 Kuro－DOM Node 的建立、刪除與修改：本文最主要的參考範例。 "},{"title":"#49 DOM：節點新增","date":"2023-12-11T16:00:00.000Z","url":"/javascript/20231212/929725069/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"針對不同元素、節點，DOM 有不同的新增方式。 快速了解新增元素使用 document.createElement() 可以建立一個新元素。透過這個方式新增的元素，還需要藉由 appendChild() 、 insertBefore() 或 replaceChild() 等方法將其加入到指定位置，才能顯示。例如：針對新建立的 newDiv 元素加入指定的 id 與 class 屬性。 上述程式碼會建立一個新的 div 元素，再添加到 的最尾部。 新增文字節點使用 document.createTextNode() 可以建立文字節點，在括號內加入字串即可。和 document.createElement() 一樣，這個新增的文字節點在被加入到某個節點前，在瀏覽器上看不到。 新增 DocumentFragment DocumentFragment 是一種特殊的 DOM 節點，它是沒有父層節點的「最小化文件物件」。可以將其視為一個輕量化的 document ，用如同標準文件一般的方法來保存「片段的文件結構」。 上述程式碼會建立一個「有三個項目的列表清單」。 document.write()使用 document.write() 不只可以新增字串和 HTML 標籤，甚至可以加入 &lt;script&gt; 標籤。當網頁已經讀取完成後，才會執行 document.write() 並將內容輸出，這時新增的內容會完全覆蓋掉目前的網頁。 小知識 因為 DocumentFragment 不是真實的 DOM 結構，所以它的變動不會影響目前的網頁文件，也不會導致回流（reflow）或引起任何影響效能的情況。因此，當需要進行大量的 DOM 操作時，用 DocumentFragment 的效能會比較高。 不建議使用 document.write() 語法，詳情可參見 MDN 與 stackoverflow。 了解更多 Kuro－DOM Node 的建立、刪除與修改：本文最主要的參考範例。 MDN－DocumentFragment：了解 DocumentFragment 的概念。 ExplainThis－回流 (Reflow) 和重繪 (Repaint) 是什麼？：了解瀏覽器渲染的概念。 "},{"title":"#48 DOM：選取方式差異","date":"2023-12-10T16:00:00.000Z","url":"/javascript/20231211/497814301/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"DOM 選取方式有「選取結果」與「回傳結果」兩種差異。 快速了解DOM 選取方式主要有兩種差異：選取結果與回傳結果。 選取結果差異 document.getElementById 和 document.querySelector 必定只會取得單一元素或節點，所以沒有 index 與 length 屬性。 document.getElementsBy** 和 document.querySelectorAll 則會選取多個節點或元素。 選取方式 選取結果 有無 index 與 length 屬性 document.getElementById 單一元素或節點 無 document.querySelector 單一元素或節點 無 document.getElementsBy** 多個元素或節點 有 document.querySelectorAll 多個元素或節點 有 回傳結果差異 document.getElementsBy** 回傳 HTMLColleaction； document.querySelectorAll 則回傳 NodeList。HTMLCollection 只收集 HTML 元素節點，而 NodeList 除了 HTML 元素節點，也包含文字節點、屬性節點等。這兩種都可以用「陣列索引」的方式來存取內容。HTMLCollection 與 NodeList 在大部分情況是即時更新的——即「動態的」，但透過 document.querySelector 、 document.querySelectorAll 取得的 NodeList 則是靜態的。而 NodeList 和 HTMLCollection 的差別在於，NodeList 包含任何的節點類型，HTMLCollection 則只包含 HTML 元素節點 (Element nodes)。動態集合代表：隨後在 DOM 上面新增、修改、刪除節點的操作，都會直接反應在先前得到的元素集合結果中。 選取方式 回傳結果 集合型態 document.getElementsBy** HTMLCollection 動態集合 document.querySelector NodeList 通常是靜態，特殊情況是動態 小知識 注意！ document.getElementsBy** 的「Element」後面有個 s。 了解更多 Kuro－透過 DOM API 查找節點：本文最主要的參考範例。 Fooish－DOM 查找元素 (DOM Traversing)：了解 DOM 選取方式的差異。 "},{"title":"#47 DOM：節點關係","date":"2023-12-09T16:00:00.000Z","url":"/javascript/20231210/3807371373/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"DOM 節點是階層架構，有父子關係與兄弟關係兩種。 快速了解DOM 節點有分層的概念，大致可以把節點之間的關係分成兩種： 父子關係：除了 document 之外，每一個節點都會有個上層的節點，稱之為「父節點」（Parent node）；相對地，從屬於自己上層的節點被稱為「子節點」（Child node）。 兄弟關係：有同一個「父節點」的節點們，彼此之間互為「兄弟節點」（Sibling node）。 父子關係 Node.childNodes：可以取得子元素，回傳值可能會是元素節點、文字節點（包括空白）或註解節點。 Node.firstChild：可以取得 Node 節點的第一個節點，若無子節點則回傳 null 。 Node.lastChild：可以取得 Node 節點的最後一個節點，若無子節點則回傳 null 。 Node.parentNode：可以取得父元素，回傳值可能會是一個元素節點、根節點或 DocumentFragment 節點。 兄弟關係 Node.previousSibling：可以取得同層之間的前一個節點，若已是第一個節點則回傳 null 。 Node.nextSibling：可以取得同層之間的後一個節點，若已是最後一個節點則回傳 null 。 節點查找遍歷範例試著透過以下範例，檢驗自己對「節點查找遍歷」的了解： 小知識 基本上，隔層的節點沒有關係，所以並沒有爺孫節點、表堂兄弟節點這種存在。 NodeList 物件常被誤認為是陣列，雖然它同樣帶有 length 屬性且可以透過 [] 加上索引的方式來存取，但它只是一個特殊的「物件」，而不是陣列，因此原生陣列方法不適用於 NodeList 物件上。 Node.firstChild 和 Node.lastChild 的子節點包括「空白」節點。 Node.textContent 會回傳目標的字串內容或 null 。 了解更多 Kuro－透過 DOM API 查找節點：本文最主要的參考範例。 MDN－NodeList：了解 NodeList 物件的概念。 "},{"title":"#46 DOM：節點類型","date":"2023-12-08T16:00:00.000Z","url":"/javascript/20231209/4150368758/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"DOM 有多種節點類型與常數。 快速了解 document 物件是整個 DOM tree 的根節點，因此，要存取 HTML 時，都是從 document 物件開始。DOM 節點類型除了「元素節點」（element nodes）外，還有「文字節點」（text nodes）、「註解節點」（comment nodes）。 節點類型整理常見的 DOM 節點類型常數 （Node type constants）有以下幾種： 節點類型常數 對應數值 說明 node.ELEMENT_NODE 1 HTML 元素的 Elements 節點 node.TEXT_NODE 3 實際文字節點，包含換行與空格 node.COMMENT_NODE 8 註解節點 node.DOCUMENT_NODE 9 根節點（Document） node.DOCUMENT_TYPE_NODE 10 文件類型的 Document 節點，例如： &lt;! DOCTYPE html&gt; 。 node.DOCUMENT_FRAGMENT_NODE 11 DocumentFragment 節點 可以透過 nodeType 屬性判斷「常數」或「對應數值」來判斷節點類型。 了解更多 Kuro－透過 DOM API 查找節點：本文最主要的參考範例。 Fooish－DOM 節點物件的屬性：了解更多種 DOM 節點物件的屬性。 "},{"title":"#45 DOM：節點選取","date":"2023-12-07T16:00:00.000Z","url":"/javascript/20231208/747586579/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"DOM 有多種選取方式，例如：標籤名稱、class、id、選擇器等。 快速了解常見的 DOM 選取方法有以下幾種： 針對給定的 tag 名稱，回傳所有符合條件的集合。 針對給定的 class 名稱，回傳所有符合條件的集合。 針對給定的 Selector 名稱，回傳第一個符合條件的集合。 針對給定的 Selector 名稱，回傳所有符合條件的集合。 節點選取範例試著在 HTML 檔案中選取 h1 標籤。 小知識 document.querySelector 與 document.querySeletorAll 可以用「CSS 選擇器」來取得「第一個」或「所有」符合條件的元素集合（NodeList）。 了解更多 Kuro－透過 DOM API 查找節點：本文最主要的參考範例。 MDN－CSS 選擇器：了解 CSS 選擇器的概念。 "},{"title":"#44 DOM 環境配置","date":"2023-12-06T16:00:00.000Z","url":"/javascript/20231207/2560653094/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"將 &lt;script&gt; 標籤放在 &lt;/body&gt; 之前，才能讓網頁被完整解析成 DOM tree。 快速了解通常來說，JS 的 &lt;script&gt; 標籤有兩種擺放位置： 放在 &lt;head&gt; ... &lt;/heade&gt; 之間。 放在 &lt;/body&gt; 之前。然而，放在 &lt;head&gt; ... &lt;/heade&gt; 之間的 JS 卻可能無法作用，這跟瀏覽器的執行原理有關。 瀏覽器執行原理當網頁被載入到瀏覽器時，瀏覽器會先分析該 HTML 檔案，由上往下依序讀取分析。如果瀏覽器在 &lt;head&gt; ... &lt;/heade&gt; 之間遇到 &lt;script&gt; 標籤，就會暫停解析網頁，並且立即執行 &lt;script&gt; 裡的內容，直到所有內容都執行完畢後，才會再繼續解析網頁。這樣的情況會導致 JS 無法作用的結果，因為在 &lt;head&gt; ... &lt;/heade&gt; 之間的 &lt;script&gt; 試圖去尋找「尚未被解析到的 HTML 內容」，卻無從取得，最後只能呈現「JS 無法作用」的狀態。但如果瀏覽器是在 &lt;/body&gt; 之前才讀取到 &lt;script&gt; 標籤，由於該網頁已經解析成 DOM 節點，使 JS 可以順利操作網頁節點，成功顯示開發者欲展現的內容。 了解更多 Kuro－透過 DOM API 查找節點：本文最主要的參考範例。 #43 DOM 的差別與重要性：回顧網頁載入流程。 "},{"title":"#43 DOM 的差別與重要性","date":"2023-12-05T16:00:00.000Z","url":"/javascript/20231206/1110551957/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"了解 BOM 與 DOM 的區別就是明白如何操作網頁的第一步。 快速了解前面介紹過，DOM 的 document 其實也是 BOM window 物件的子物件之一。 BOM 與 DOM 的區別BOM 與 DOM 的區別在於： BOM：是 JS 與「瀏覽器」溝通的窗口，不涉及網頁內容；本身無標準規範，完全依賴於瀏覽器廠商實作。 DOM：是 JS 用來控制「網頁」的節點與內容的標準；有 W3C 所制定的規範標準。 DOM 的重要性只要遵守 W3C 制定的規範，不管是任何平台或任何開發語言，都可以透過 DOM 提供的 API 來操作 DOM 的內容、結構與樣式。當一個網頁被載入到瀏覽器時，瀏覽器會先分析這個 HTML 檔案，再依照這份內容解析成 DOM。換句話說，DOM 是網頁的根本，懂得控制 DOM 就可以控制整個網頁，做出良好的互動體驗。對於前端工程師來說，了解如何與瀏覽器打交道、如何運用 JS 操作網頁內容，就是做好 WebUI 最重要的基礎。 了解更多 Kuro－前端工程師的主戰場：瀏覽器裡的 JavaScript：本文最主要的參考範例。 "},{"title":"#42 DOM","date":"2023-12-04T16:00:00.000Z","url":"/javascript/20231205/2401154791/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"DOM API 讓 JS 可以對操作網頁內容。 快速了解DOM（Document Object Model），文件物件模型，是一個將 HTML 文件以樹狀結構來呈現的模型。其組合起來的樹狀圖被稱為「DOM tree」。DOM 會把 HTML 文件行程一個個「節點」（node），再組成一個樹狀結構。在最根部的位置，是 document 。往下延伸出 HTML 標籤節點，一個節點就是一個標籤（Element）。再往下又可以延伸出「文本節點」（Text）與「屬性節點」（Attribute）。 DOM 選取方式DOM API 定義了多種方法，讓 JS 可以存取、改變 HTML 架構、樣式和內容，甚至可以對節點綁定事件。使用 JS 取得網頁中元素的方式有很多種，例如： 根據 id 名稱選取： document.getElementById() 。 根據元素名稱選取所有符合條件者： document.getElementsByTagName() 。 根據 class 名稱選取所有符合條件者： document.getElementsByClassName() 。 根據條件選取第一個符合條件者： document.querySelector() 。 根據條件選取所有符合條件者： document.querySelectorAll() 。總結來說，JS 就是透過 DOM 提供的 API 來對 HTML 進行存取與操作。 小知識 document 是 window 物件的其中一種屬性。 了解更多 Kuro－前端工程師的主戰場：瀏覽器裡的 JavaScript：本文最主要的參考範例。 陳奕帆 Andy Chen－深入理解網頁架構：DOM：了解 DOM tree 的結構。 "},{"title":"#41 BOM","date":"2023-12-03T16:00:00.000Z","url":"/javascript/20231204/3425939589/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"BOM 有兩種功能：全域物件與瀏覽器溝通窗口。 快速了解BOM（Browser Object Model），瀏覽器物件模型，是瀏覽器所有功能的核心，與網頁的內容無關。 window 物件BOM 的核心是 window 物件。 window 物件提供的屬性主要有 document 、 location 、 navigator 、 screen 、 history 及 frames 。在瀏覽器裡的 window 物件扮演著兩種角色： ECMAScript 標準裡的「全域物件」（Global Object）。 JavaScript 用來與瀏覽器溝通的窗口。 全域物件作為 JavaScript 的全域物件， window 物件包含了所有全域變數與函式，通常會把這些變數稱為「全域變數」，可以透過 window.xxx 取得它們。 在「全域作用範圍」宣告的全域變數雖然屬於 window 的屬性，但它無法使用 delete 關鍵字移除。 但如果是直接透過指定 window 物件的屬性，就可以成功刪除。 瀏覽器的溝通窗口瀏覽器環境的 BOM 與 window 物件提供了多種內建功能的 API，例如：開啟或關閉視窗、改變視窗大小、計時器與取得網址等。window 物件只需要一行程式碼即可生成一個對話框。舉例來說：用 alert() 產生一個「警告對話框」。 實際上， window.alert(&quot;Hello!&quot;); 才是完整語法，但因為全域物件的特性， window 可以省略不打。 小知識 BOM 有時被稱為「Level 0 DOM」，是因為它在 DOM Level 1 標準前就已存在，而非真的有文件規範。 在「全域作用範圍」內宣告的變數、物件、函式，都會自動變成「全域物件」的屬性。 了解更多 Kuro－前端工程師的主戰場：瀏覽器裡的 JavaScript：本文最主要的參考範例。 MDN－Window：了解更多 window 物件的屬性與方法。 Samuel－BOM和DOM筆記：觀看常用的 window 屬性及說明。 #34 全域變數與區域變數：回顧「全域物件」的概念。 "},{"title":"#40 瀏覽器與 JS","date":"2023-12-02T16:00:00.000Z","url":"/javascript/20231203/1229881720/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"瀏覽器提供網頁的操作方法，讓 JS 可以網頁中運作。 快速了解在學習前端知識時，你可能聽過這個說法：「HTML、CSS 與 JavaScript 是網頁前端三大要素」。由 HTML 負責資料與結構，CSS 負責樣式與呈現，JavaScript 負責行為與互動。但事實上，JS 並沒有提供網頁的操作方法，前端開發者在網頁上的操作方法都由 JS 的執行平台——「瀏覽器」提供。基本上，這些操作方法會分別由「BOM」與「DOM」這兩種物建所擁有。因此，在瀏覽器上的 JS 包含了三個部分： JavaScript 核心（以 ECMAScript 標準為基礎） BOM（Browser Object Model，瀏覽器物件模型） DOM（Document Object Model，文件物件模型）前端開發者就是透過 JS 去呼叫 BOM 與 DOM 提供的 API，再進一步透過它們去控制瀏覽器的行為與網頁的內容。 小知識 瀏覽器都會包含一個渲染引擎（rendering engine），負責解釋網頁上的程式碼，瀏覽器的 JS 解譯器就是該引擎的一部份。 了解更多 Kuro－前端工程師的主戰場：瀏覽器裡的 JavaScript：本文最主要的參考範例。 "},{"title":"#39 可變的","date":"2023-12-01T16:00:00.000Z","url":"/javascript/20231202/1332088474/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"物件型別的「可變」特性，使其內容可以直接被更新。 快速了解JS 的型別中，只有物件型別是可變的（Mutable），並且會透過「傳址」方式傳遞參數。換句話說，物件型別以記憶體的「位址」為基準，來進行更新或複製，並非以「值」為基準。因此，當物件更新時，會影響到所有引用該物件的變數與其副本。 物件更新因為可變的特性，呼叫某些函式時，有可能會更動到原本記憶體位置儲存的東西。 在原本的陣列 arr 透過 arr.push 的方式呼叫，會更動到原本的陣列，使最後印出結果為 [2, 4, 6, 8] 。這時，如果使用「重新賦值」的方式印出結果，將會產生不同的內容。 在上述案例中，重新賦值會讓原本的陣列做兩件事情：新增元素到陣列、回傳陣列長度（arr.length）。使得最後印出結果變成陣列長度的 4 。 小知識 通常來說，不會改動到陣列的「內建函式」，其回傳結果都不是陣列，例如： array.join() 回傳結果為字串。 了解更多 文科少女學程式－JavaScript的mutable與immutable：詳細了解「可變的」意義。 #36 參數傳遞：Pass by reference：回顧「傳址」方式。 "},{"title":"#38 不可變的","date":"2023-11-30T16:00:00.000Z","url":"/javascript/20231201/2821490299/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"基本型別的「不可變」特性，使其值必須重新賦值才能更新。 快速了解除了物件以外，其他基本型別（primitive types）都具有不可變的特性，並且會透過「傳值」方式傳遞參數。換句話說，基本型別以「值」為基準，而不是以「址」為基準，每個值都是獨立的，就算值看起來是相等的，其所佔的記憶體位置也不一樣。 純值的重新賦值因為不可變的特性，原本的值和後來的值是完全獨立的關係，必須要透過 = 重新賦值，才能讓後來的值取代原本的值。 變數 a 原本的值為「hello」，在宣告時被儲存在 0x01 的位置；被重新賦值時，後來的值「yo」不會取代舊值的位置，而是建立新的記憶體空間 0x02 來存放。 內建函式的重新賦值由於字串具有不可變的特性，因此，不論呼叫什麼函式均無法改變 a 的值。必須要透過重新賦值，才能更新原本的值。 在範例一，試著透過內建函式 toUpperCase() 呼叫，使變數 a 的字串更新為大寫。但如果只對基本型別的值進行呼叫，不會有任何改變，回傳結果仍是原本的值—— hello 。而範例二，則透過重新賦值的方式，讓變數 a 指向了新的記憶體位置——即 toUpperCase() 的結果，才成功印出更新的值 HELLO 。 了解更多 文科少女學程式－JavaScript的mutable與immutable：詳細了解「不可變的」意義。 #35 參數傳遞：Pass by value：回顧「傳值」方式 "},{"title":"#37 參數傳遞：Pass by sharing","date":"2023-11-29T16:00:00.000Z","url":"/javascript/20231130/3304160290/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"事實上，JS 是以 Pass by sharing 的方式傳遞參數。 快速了解大多數情況下，基本型別是「傳值」，物件型別是「傳址」。但實際上，JS 不屬於單純的「傳值」或「傳址」。準確來說，JS 是透過「Pass by sharing」的方法來傳遞參數。 Pass by sharingPass by sharing 的特點在於：當 function 的參數被重新賦值時，外部變數的內容不會被影響。而如果不是重新賦值的情況，則會跟 Pass by reference 的結果一樣。 可變的與不可變的JS 型別具有兩種特性：可變的（mutable）與不可變的（immutable）。物件型別是可變的，代表當物件更新時，會影響到所有引用這個物件的變數與其副本，修改時會變動到原本的參考。但在賦與新值時，卻會產生新的實體參考。基本型別則是不可變的，代表更新某個基本型別的值時，與該值的副本完全無關。在操作基本型別時，Pass by sharing 與 Pass by value 的結果一樣，修改時永遠只能賦與新值。 小知識 參數傳遞方式與 JS 的深拷貝（Deep copy）、淺拷貝（Shallow copy）方法相關。 了解更多 Kuro－JavaScript 是「傳值」或「傳址」？：本文最主要的參考範例。 itsems－Javascript中的傳值 by value 與傳址 by reference：了解 Pass by sharing 方法。 Huli－深入探討 JavaScript 中的參數傳遞：深入了解參數傳遞與深、淺拷貝方法。 "},{"title":"#36 參數傳遞：Pass by reference","date":"2023-11-28T16:00:00.000Z","url":"/javascript/20231129/1891124894/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"物件型別是以 Pass by reference 的方式傳遞參數。 快速了解物件型別指的是可能由零或多種不同型別（包含純值與物件）所組成的物件。在比較、更新與傳遞時，會以「實體參考」的形式進行，這種參數傳遞方式被稱為「傳址」（Pass by reference）。 物件型別的比較JS 的物件可以被視為是一個「實體」（instance）。對於兩個不同的實體來說，即使它們內容的「值」一樣，也不表示它們相等。 雖然 box1、box2 看起來「等值」，但這並不是「box1 等於 box2 」的意思。 物件型別的更新與傳遞物件是透過「引用」方式傳遞資料，接收的對象是引用的「參考」而不是「值」的副本。因此，當被引用的參考內容被更新時，引用者的內容也會一併更新。在此時，透過 === 去檢查兩個實體，會發現兩者實際上是同一個實體。 這個流程是這樣運作：首先在建立一個物件時，JS 會在記憶體某處建立一個物件，再將 box1 變數指向該新生成的物件。接著，宣告第二個變數 box2 後，透過 = 將其指向 box1 的位置。最後，當 box1.value 的內容更新，box2.value 也一起被更新。 了解更多 Kuro－JavaScript 是「傳值」或「傳址」？：本文最主要的參考範例。 itsems－Javascript中的傳值 by value 與傳址 by reference：了解傳址方法。 "},{"title":"#35 參數傳遞：Pass by value","date":"2023-11-27T16:00:00.000Z","url":"/javascript/20231128/1868702299/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"基本型別是以 Pass by value 的方式傳遞參數。 快速了解基本型別內的資料，會以純值的形式存在。在比較、更新與傳遞時，也會以「值」的形式進行，這種參數傳遞方式被稱為「傳值」（Pass by value）。 基本型別的比較在基本型別時，會透過變數裡面的內容——即「值」——來判斷兩個變數是否相等。 基本型別的更新與傳遞在基本型別的變數中，看的是變數裡的「值」。舉例來說，在複製變數時，複製的是該變數的「值」。 變數 b 的值是透過複製變數 a 的值而來。但這不代表當變數 a 更新後，會影響變數 b 的數值： 變數 a、b 是各自獨立的，變數 b 看起來是透過複製變數 a 而來，實際上，是變數 b 建立了一個新的值，再將變數 a 的內容複製過去。因此，當變數 a 的內容後來經過更新變成 100 後，變數 b 的內容不受影響，依然是原本的 10。 了解更多 Kuro－JavaScript 是「傳值」或「傳址」？：本文最主要的參考範例。 itsems－Javascript中的傳值 by value 與傳址 by reference：了解傳值方法。 "},{"title":"#34 全域變數與區域變數","date":"2023-11-26T16:00:00.000Z","url":"/javascript/20231127/3502683458/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"實際上，全域變數是指「全域物件」的屬性。 快速了解其實在 JS 中，並不存在「全域變數」。更準確地說，我們所說的「全域變數」是指「全域物件」（或稱「頂層物件」）的屬性。 全域物件以瀏覽器來說，「全域物件」指的是 window ，在 node 環境中則叫做 global 。全域物件的「屬性」是什麼意思呢？來看看下面的範例： 在前面章節中，我們一直稱呼 var a = 10; 為「全域變數」，但當我們想印出 window.a 時，會獲得的結果即是 10 ！因此，「全域變數」是指全域物件的「屬性」。 變數整理 變數有效範圍的最小切分單位是 function ， let 和 const 除外。 let 和 const 是區域變數，以大括號 &#123;&#125; 區塊的程式碼為作用範圍。 即使寫在函式內，沒有 var 宣告的變數都會變成「全域變數」。 全域變數指的是全域物件（頂層物件）的「屬性」。 了解更多 Kuro－函式的基本概念：本文最主要的參考範例。 Tim－全域變數與區域變數：了解全域變數與區域變數的概念。 #8 資料型別：物件：回顧物件的屬性觀念。 "},{"title":"#33 暫時性死區","date":"2023-11-25T16:00:00.000Z","url":"/javascript/20231126/1744441320/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"let 與 const 的宣告提升時，會產生暫時性死區。 快速了解暫時性死區（Temporal Dead Zone, TDZ）是只有 let 與 const 才具有的特性，專門用來解釋它們的提升行為。 let 與 const 的提升 let 與 const 也有提升，差別在於： var 提升之後，宣告的變數會被初始化為 undefined ；而 let 與 const 的宣告則不會被初始化為 undefined，如果在「賦值之前」就存取它，就會發生錯誤。具體來說，在「提升之後」及「賦值之前」這段期間，如果存取該變數就會拋出錯誤，這段期間被稱為「暫時性死區」（TDZ）。受到 TDZ 影響，變數需要在宣告後才能使用。如果在 let 與 const 宣告前讀取變數，會引發 Uncaught ReferenceError 的錯誤。因此，不論是用何種宣告方式，使用變數前一定要先宣告。 函式宣告除了變數，函式也有提升。兩者差異為：變數提升只有宣告被提升；函式的提升則是包括內容都完全被提升。因此，函式提升優先於變數提升。函式定義方式也會有差異。透過函式宣告定義的函式，因為函式提升，可以在宣告前使用。 透過函式運算式定義的函式則會出現錯誤。 小知識 除了可呼叫的時機不同外，「函式宣告」與「函式運算式」在執行時期沒有明顯的差別。 了解更多 Kuro－函式的基本概念：本文最主要的參考範例。 阿建－JavaScript 提升(Hoisting)是什麼?關於提升的5個觀念：回顧變數提升的概念。 #26 函式：定義：回顧函式定義方式。 "},{"title":"#32 變數提升","date":"2023-11-24T16:00:00.000Z","url":"/javascript/20231125/3405801099/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"「提升」使得變數在宣告之前被使用會回傳 undefined 。 快速了解變數提升（Variables Hoisting）會把變數和函數的宣告移動到程式區塊頂端，直到實際執行時再賦值。看起來是將變數和函數的宣告「移動」到程式區塊頂端。但在編譯階段時，變數和函式的宣告會先被放入記憶體，實際在程式碼中位置還是一樣。換言之，如果在宣告前使用相應的變數，瀏覽器會先將該變數「提升」至程式區塊頂端並宣告，但尚未賦值，因此，此時會印出 undefined ，直到程式執行到相關的宣告程式碼時，才會賦值。舉例來說： 在宣告變數 word 時尚未賦值，只會印出 undefined 的結果；直到變數 word 被執行並賦值時，才會回傳 hello 的結果。 進階案例 在這個案例中， console.log(x) 的回傳值會是 undefined 。因為，對瀏覽器來說，這時的程式碼會呈現下面的樣子： JS 會先在自己的作用域尋找變數 x ，發現在下面的 var x = 100 有宣告，就只會把「宣告的語法」提升到該作用域（即這個案例的 function ）的最上面，因此只會印出 undefined 的結果。 解決方式為了解決 JS 「變數提升」的奇怪特性，建議使用以下兩種方式： 先宣告再使用，所有可能用到的變數都盡量在「作用域的最上面」宣告完成後再使用。 使用 ES6 的 let 或 const 代替，因為 let 宣告的變數不會有變數提升的特性。 小知識 只有宣告的變數會提升，賦值不會提升。 了解更多 Kuro－函式的基本概念：本文最主要的參考範例。 MDN－提升：了解變數提升的概念。 阿建－JavaScript 提升(Hoisting)是什麼?關於提升的5個觀念：了解變數提升的概念。 Huli－我知道你懂 hoisting，可是你了解到多深？：深入了解變數提升的概念。 "},{"title":"#31 變數的有效範圍","date":"2023-11-23T16:00:00.000Z","url":"/javascript/20231124/3746595863/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"除了 let 與 const ，切分變數有效範圍的最小單位是 function 。 快速了解變數的有效範圍被稱為「作用域」（Scope），而切分變數有效範圍的最小單位是 function 。在 ES6 之前，JS 變數有效範圍的最小單位是以 function 作為分界。（ES6 新增的 let 與 const 例外）舉例來說： 上述程式碼代表著：在函式區塊內透過 var 定義的 x 變數只屬於這個函式，函式外的 x 與函式內的 x 是兩個不同的變數。因此， doSomeThing(50) 會印出 100 + 50 的 150 ； x 則會印出函式外面的 1 。 找不到指定變數的情況 如果 function 內沒有 var x 的話，在自己的 內沒有找到，就會一層層往外找，直到「全域變數」為止。 沒有 var 宣告變數的情況在下面案例中，把 function 內的 var 拿掉。 因為「切分變數有效範圍的最小單位是 function 」的特性，如果 function 內部沒有使用再次用 var 宣告某變數，JS 就會再往外層查找有無同名的變數，直到最外層的「全域物件」為止。因此，這會使得 function 內的 x = 100 變更了外層的同名變數 x 。 小知識 與 var 不同， let 與 const 的作用域是透過大括號 &#123;&#125; 來切分，且 let 不允許重複宣告。 函式外層無法使用內層宣告的變數，但內層可以使用外層的變數。 最外層的「全域物件」，以瀏覽器來說，就是 window 了解更多 Kuro－函式的基本概念：本文最主要的參考範例。 Lochs－Scope 作用域：了解三種作用域概念與預習作用域鏈的觀念。 "},{"title":"#30 變數宣告","date":"2023-11-22T16:00:00.000Z","url":"/javascript/20231123/704880787/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"變數宣告與後續會提到的 JS 觀念息息相關。 快速了解我們之前介紹過，變數有三種宣告方式： var 、 let 、 const 。過去通常會使用 var 宣告變數，直到 ES6 新增了區域變數 let 、 const ，開發者們逐漸以此取代 var 。 var 宣告對象為變數（Variable）。 變數有效範圍為函式作用域。 允許重複宣告。 可以重新賦值。 宣告前就存取對應變數，會得到 undefined 。 let 宣告對象為變數（Variable）。 變數有效範圍為區塊作用域，是區域變數。 同一個區塊作用域中不允許重複宣告。 可以重新賦值。 宣告前就存取對應變數，會得到 ReferenceError 錯誤。 const 宣告對象為常數（Constant）。 變數有效範圍為區塊作用域，是區域變數。 同一個區塊作用域中不允許重複宣告。 不可以重新賦值。 宣告前就存取對應變數，會得到 ReferenceError 錯誤。 宣告時一定要給值。 宣告方式整理 var let const 宣告對象 變數 變數 常數 有效範圍 函式作用域 區塊作用域 區塊作用域 能否重複宣告 可 同一個區塊作用域中不可 同一個區塊作用域中不可 能否重新賦值 可 可 不可 宣告強度 弱 中 強 嚴謹程度 低 高 高 小知識 var 與 let 的差別在於： var 是以 function 為作用域； let 則是以大括號 &#123;&#125; 區塊的程式碼為作用的範圍。 了解更多 ㄚ淳淳－const、let、var的區別—DAY3：了解三種宣告的差異與練習題目。 popeye_ux－變數宣告var、let、const的區別：透過案例了解三種宣告的差異。 程式碼農－JS 宣告變數， var 與 let &#x2F; const 差異：了解更詳細的三種宣告差異。 "},{"title":"#29 常用的內建函式：Array","date":"2023-11-21T16:00:00.000Z","url":"/javascript/20231122/154092581/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"學習 Array 內建函式，可以讓程式碼更簡潔。 快速了解內建函式可以讓程式碼更簡潔，但並非必要，使用一般程式碼也可以完成這些功能。以下分享一些 Array 常用的內建函式。 join.() ：將陣列中所有元素連接成一個字串，預設分隔符是逗號。 map() ：把陣列中的每個元素帶入指定函式，然後建立一個新的陣列。 filter() ：概念和 map() 類似，會根據指定的測試函數，從一個陣列中過濾出符合條件的元素，並建立新的陣列。 slice() ：可截取出陣列某部份元素，會建立一個新的陣列，其意義為「自哪一個索引開始提取，到哪一個索引之前結束」。 splice() ：可用來刪除與新增元素，會改變原本的陣列。 sort() ：依照字母順序排列陣列中的所有元素，會改變原本的陣列。 小知識 在使用 sort() 時，因為數字被轉換成字串，在 Unicode 順序中 &quot;80&quot; 會在 &quot;9&quot; 的前面。 了解更多 MDN－Array：了解 Array 的常見函式。 "},{"title":"#28 常用的內建函式：String","date":"2023-11-20T16:00:00.000Z","url":"/javascript/20231121/1909286593/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"學習 String 內建函式，可以讓程式碼更簡潔。 快速了解內建函式可以讓程式碼更簡潔，但並非必要，使用一般程式碼也可以完成這些功能。以下分享一些 String 常用的內建函式。 toUpperCase 、 toLowerCase ：將字串轉換大、小寫。 .charCodeAt() ：取得字串特定位置的字元 ASCII 編碼。 String.fromCharCode()：將 ASCII 編碼的數字轉換成字元。 indexOf() ：可回傳「指定字串」在字串中第一次出現的位置，若找不到則回傳 -1。 replace() ：取代字串，只能換第一個指定字串。 split() ：透過「指定分隔符」來分開字串，回傳值為陣列。 trim() ：移除目前字串開頭和結尾的所有空格。 string.length ：可回傳字串長度，常搭配迴圈使用。備註：此指令不是函式。 ASCIIASCII 是「美國標準資訊交換碼」，每一個可顯示字元都有自己專屬的索引，大、小寫字母的索引相差 32。 利用 ASCII code 進行字串比大小，可判斷該字元為大小寫、是否在條件範圍內： 如果想要取代「所有的」指定字串，可以使用正規表達式（Regular expressions）達成： 了解更多 MDN－String：了解 String 的常見函式。 維基百科－ASCII：了解 ASCII 編碼的意義。 MDN－正規表達式：了解正規表達式的使用方式。 "},{"title":"#27 常用的內建函式：Number","date":"2023-11-19T16:00:00.000Z","url":"/javascript/20231120/576908797/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"學習 Number 內建函式，可以讓程式碼更簡潔。 快速了解內建函式可以讓程式碼更簡潔，但並非必要，使用一般程式碼也可以完成這些功能。以下分享一些 Number 常用的內建函式。 Number() ：將字串轉數字。 parseInt() ：將字串轉整數，預設為十進位，例如：parseInt(a, 10) 。 parseFloat() ：將字串轉浮點數，即有小數點。 toFixed() ：取到小數點後第幾位，括號內不輸入就會取整數。 .toString()：數字轉字串。 Number.MAX_VALUE 、 Number.MIN_VALUE ：得知在 JS 可儲存的最大、最小值，若超出這個值，計算就會不精準。 Math.PI ：圓周率。Math.ceil() ：無條件進位，取大於這個數的最小整數。 Math.floor() ：無條件捨去，取小於這個數的最大整數。 Math.round ：四捨五入。 Math.sqrt()：開根號。 Math.pow(x, y)：次方，取 x 的 y 次方。 Math.random ：產生 0～1 之間的隨機小數（不包含 1） 。 小知識 常數會用大寫英文字母表示，例如： PI 。 toFixed() 常與 parseFloat() 搭配使用。 數字轉字串的另一個方式：數字加空字串（ &#39;&#39; 或 &quot;&quot; ）。 了解更多 MDN－Number：了解 Number 的常見函式。 MDN－Math：了解 Math 的常見函式。 "},{"title":"#26 函式：定義","date":"2023-11-18T16:00:00.000Z","url":"/javascript/20231119/115912181/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"函式有三種定義方式，並可分為具名、匿名兩種。 快速了解函式有三種定義方式： 函式宣告（Function Declaration）。 函式運算式（Function Expressions）。 透過關鍵字 new Function 建立函式。 函式宣告「函式宣告」是最常見的用法。 函式運算式將函式透過 = 指定給某個變數。 透過關鍵字 new Function 建立函式。因效能較差，實務上較少使用。使用關鍵字 new Function 建立函式物件。將參數與函式的內容依序傳入 Function ，即可建立一個函式物件。 匿名函式在前面「函式運算式」的範例中，可以發現：該函式是「沒有名字」的。這種沒有名字的函式被稱為「匿名函式」。 小知識 有名字的「具名函式」只在「自己函式的區塊內」有效，換言之，脫離函式自身的 &#123;&#125; 區塊後，該變數就不存在。 了解更多 Kuro－函式的基本概念：本文最主要的參考範例。 MDN－函式：了解函式的常見用法。 Tim－具名函式與匿名函式的基本認識：了解匿名函式的使用方式。 OneJar－函數定義 (Function Definition) 的 100 種寫法：了解更多種函式定義方式。 "},{"title":"#25 函式：宣告","date":"2023-11-17T16:00:00.000Z","url":"/javascript/20231118/1806621739/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"函式是物件的一種，具有可重複使用的特性。 快速了解函式（function）會將一或多段程式指令包裝起來，可以重複使用，也方便維護。可以同時註冊多組函式，函式裡也可以執行其他函式。 函式結構通常來說，一個函式會包含以下三個部分： 函式名稱（備註：也可能沒有名稱）。 在小括號中的部分為「參數（arguments）」，參數與參數之間會用逗號隔開（備註：不一定需要參數，但括號不可省略）。 大括號中則是需要「重複執行」的內容，是函式功能的主要區塊。 函式呼叫所有的函式都有回傳值，回傳值可以用關鍵字 return 來指定。定義為：宣告一個變數，其值為函式，待函式執行完， return 會將結果為傳至函式，並賦予到變數上。如果沒有使用 return 回傳，預設會回傳 undefined 。 函式範例 function ：使用關鍵字 function 宣告一個函式。 totalPrice ：函式名稱。 (item1, item2) ：參數。 return item1 + item2; ：會回傳的執行區塊。 oldList 、 newList ：宣告變數， return 會把結果傳到函式，再賦予至變數。 小知識 使用 typeof 檢查一個函式時，會得到 function 的結果。但實際上，函式仍屬於物件型別（ object ）。 參數跟變數不同，參數只存活在大括號裡。在函式外，印出參數會回傳錯誤。 函式可以分成兩種：不需要知道結果、需要回傳值。前者有無 return() 並不影響結果，通常只會用 console.log() 印出結果；後者則必須要透過 return() 得到回傳值。 了解更多 Kuro－函式的基本概念：本文最主要的參考範例。 MDN－函式：了解函式的常見用法。 "},{"title":"#24 變數儲存模型","date":"2023-11-16T16:00:00.000Z","url":"/javascript/20231117/1831802184/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"記憶體儲存概念：一般的東西存資訊，物件存記憶體位置。 快速了解說到「變數資料」與「記憶體存放」的觀念，就必須先了解：在任何一個程式語言中，操作資料前，你會需要先找到一個地方放置這些資料，這個地方就是「變數」。變數會提供一個「暫時儲存資料」的地方，透過一個可以識別的名字，將資料寫進記憶體。 記憶體存放流程變數與資料操作的實際情況，在電腦上發生的是： 你在記憶體上宣告（declare）了一組變數。 你在記憶體上創建（create）了一筆資料。 變數指向（assign）這筆資料。以下列程式碼為例： 使用 let 的方式，宣告一個名為 appleColor 的變數，並對應到一筆 &quot;red&quot; 的資料。 物件型別的情況如果想存物件或陣列，變數裡面存的內容是「指引」或「指標」，是前往某個記憶體位置的指引。換句話說，基本型別的變數存資訊，物件則存在記憶體位置。 了解更多 Huli－從博物館寄物櫃理解變數儲存模型：最白話的案例帶你了解變數儲存。 MDN－記憶體管理：深入了解 JS 的記憶體管理。 ALPHACamp－變數與值：複習變數與值的關係。 "},{"title":"#23 迴圈：break 與 continue","date":"2023-11-15T16:00:00.000Z","url":"/javascript/20231116/2461366595/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"break 和 continue 都能中斷迴圈，但兩者的功能並不同。 快速了解使用迴圈時，有時會需要跳過其中幾次或提早離開迴圈。這時，可以使用 break 和 continue 語法。 break 語法 break 會直接跳離迴圈。例如：在包含一堆 0 和其他數字的陣列中找出不是 0 的「第一個數字」。 找出那個不是 0 的「第一個數字」，印出後再退出迴圈。 continue 語法 continue 會跳過一次，再繼續下一次的迴圈。例如：當我們要印出 1～10 的所有正整數，但跳過 3 的倍數。 在此案例中， i 能被 3 整除表示 i 是 3 的倍數，遇到 continue 則會跳過。 小知識 在迴圈中，可能會常看到 arr.length 的類似語法，這代表「陣列的長度」，常被放在 for 的條件部分。 了解更多 Kuro－流程判斷與迴圈：本文最主要的參考範例。 MDN－break 語法：了解 break 的常見用法。 MDN－continue 語法：了解 continue 的常見用法。 ALPHACamp－Loop 迴圈：了解 JS 的迴圈用法。 "},{"title":"#22 迴圈：while","date":"2023-11-14T16:00:00.000Z","url":"/javascript/20231115/1598197283/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"相較於 for 迴圈， while 語法更單純易懂。 快速了解 for 和 while 這兩種迴圈語法的原理大同小異，但相較 for 語法， while 迴圈的語法更單純一些。 while 迴圈 while 語法只由條件組成。小括號內是「執行迴圈的條件」，指滿足該條件時，會進入大括號區塊，再執行內部程式。 以上述為例： i = 0 是初始值。 i &lt; 10 是條件。 i++ 是結束迴圈的更新敘述。 console.log(i) 是敘述，即函式要做的事。 for 與 while 的差異 for 和 while 迴圈的特性都是「只要指定條件是 true 」就可以進入重複執行的區塊，因此，在大部分情況下，它們兩者能做的事情一樣。但因為 for 語法包含了「初始值」、「條件」、「結束迴圈的更新敘述」等，而 while 語法只包含「條件」的部分，使前者的執行次數可以一目了然。上述特性讓兩者的適用情況有區別： for 迴圈的使用情境，大多是用在迴圈執行次數「明確」的狀態。 while 迴圈的使用情境，更適合用在當迴圈執行次數「不確定」時。 小知識 不管是 for 或 while 迴圈，「完成結束的條件」都是非常重要的！若執行條件沒有設定好，可能會造成「無窮迴圈」，使程式跳不出迴圈。 了解更多 Kuro－流程判斷與迴圈：本文最主要的參考範例。 ALPHACamp－Loop 迴圈：了解 JS 的迴圈用法。 "},{"title":"#21 迴圈：for","date":"2023-11-13T16:00:00.000Z","url":"/javascript/20231114/1973875290/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"for 迴圈讓「重複做某件事」的程式變得更簡潔。 快速了解迴圈（loop）指：想要「重複做某件事，而數值會依重複次數的『遞增』或『遞減』的變化來完成退出迴圈的條件」。在 JS 中，常見的迴圈語法有 for 及 while 兩種。 不使用迴圈的案例假設要用 console.log() 從 1 印到 10 ，在沒有使用迴圈的情況下，同樣的東西必須要寫十次。 相同的案例，使用 for 迴圈只需要一半不到的行數。 for 迴圈一個典型的 for 語法會由小括號、初始值、條件、結束迴圈的更新敘述、敘述所組成。小括號內最左邊是「初始值」，用來初始化 for 迴圈中的計數器。中間的部分是「執行迴圈的條件」，當滿足該條件（結果為 true ）時，就會進入大括號的區塊，執行內部程式。最右邊則是在每次執行完大括號的程式碼後，會執行這段內容。當程式執行過右邊部分後，會再到中間條件區塊檢查，若是條件符合就繼續迴圈，否則就跳出迴圈區塊。 以上述為例： i = 1 是初始值。 i &lt;= 10 是條件。 i++ 是結束迴圈的更新敘述。 console.log(i) 是敘述，即函式要做的事。 了解更多 Kuro－流程判斷與迴圈：本文最主要的參考範例。 MDN－for 語法：了解 for 的常見用法。 ALPHACamp－Loop 迴圈：了解 JS 的迴圈用法。 "},{"title":"#20 條件判斷：三元運算子","date":"2023-11-12T16:00:00.000Z","url":"/javascript/20231113/4128159221/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"三元運算子也提供簡潔的條件判斷方式。 快速了解在 JS 的運算子種類中，存在一個用途跟 if...else 和 switch 很接近的運算子——三元運算子。三元運算子，又稱「條件運算子」，是 JS 中唯一用到三個運算元的運算子，以「條件」、「問號」、「冒號」三個元素所組成。在一個條件後面會跟著一個問號，如果條件是「truthy」，在冒號前的表達式會被執行；如果條件是「falsy」，在冒號後面的表達式會被執行。 案例說明：判斷變數 age 是否大於或等於 18，若是，則 status = &quot;成人&quot; ；若不是，則 status = &quot;小孩&quot; 。 條件判斷整理 條件判斷方式 特色 範例 if...else 推薦「入門學習者」使用 if (5 &gt; 2)&#123;console.log(”true”);&#125; else &#123; console.log(”false”);&#125; switch 推薦「複雜判斷」使用 switch()&#123;case1:…;&#125; 三元運算子 推薦「簡單判斷」使用 max = (a &gt; b)? a : b ; 小知識 三元運算子通常被用來當作 if...else 的簡潔寫法。 了解更多 MDN－三元運算子：了解三元運算子的常見用法。 ALPHACamp－流程控制 if&#x2F;else 條件判斷：複習三種流程控制的條件判斷方式。 #16 邏輯運算子：回顧「falsy」和「truthy」的觀念。 "},{"title":"#19 條件判斷：switch","date":"2023-11-11T16:00:00.000Z","url":"/javascript/20231112/52344673/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"switch 提供更簡潔的複雜條件判斷方式。 快速了解當需要複雜的條件判斷時，相較於 else...if ，更推薦使用 switch 語法。 switch 定義 switch 括號內的語法可以是「運算式」或「某個變數、值」。接下來，該內容會進入的 case 判斷流程，當它符合某個 case 條件時，會執行這個條件的陳述式；若所有 case 條件都不成立時，會執行 default 區塊的內容。 break 的重要性 case 區塊不像 if...else 使用大括號切分區塊，而是使用 break 指令來中斷執行。如果沒有插入 break 指令，可能會使所有 case 的內容都一起被執行。因此，建議務必要在 case 區塊結束前，加上 break 。 小知識 按照慣例， default 語句會是最後一個條件，但不一定要存在。 了解更多 MDN－switch：了解 switch 的常見用法。 MDN－break：預習 break 的使用方式。 "},{"title":"#18 條件判斷：if…else","date":"2023-11-10T16:00:00.000Z","url":"/javascript/20231111/961197172/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"當條件成立時會執行 if 陳述式裡的程式，否則執行另外一個陳述式。 快速了解流程控制的「條件語法」指：當指定的條件為 true 時，就會執行後續所指定的指令。JS 的條件語法有兩種： if...else switch if…else if...else 代表：當條件成立的時候會執行 if 陳述式裡的程式，否則執行另外一個陳述式。 if 陳述式裡的「條件式」是 true 或 false 的運算式。搭配之前提過「Boolean 的型別轉換」，所有 JS 資料都可以透過 ToBoolean 轉換成 true 或 false ，因此，條件式可以有任何內容。 else if當你需要新增多個條件時，多數程式語言可以用 elseif 表達。但 JS 沒有 elseif 可以使用。因此，我們可以使用「在 else 和 if中間夾著空白」的語法來取代它。 小知識 原則上， else if 沒有數量限制，但為了程式的可讀性與維護性，建議盡量減少 if...else 的條件數量。 了解更多 MDN－if…else：了解 if...else 的常見用法。 #17 自動轉型：回顧 Boolean 的型別轉換觀念。 "},{"title":"#17 自動轉型","date":"2023-11-09T16:00:00.000Z","url":"/javascript/20231110/266130255/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"不同型別的資料在運算時，JS 會先「自動轉型」。 基礎規則 如果其中一個是布林值，會將 true 轉為數字的 1， false 則變成數字的 0。 如果是字串與數字，會先透過 Number() 把字串轉為數字。 如果其中一個是「物件」型別，而另一方是基本型別時，會先透過物件的 valueOf() 方式取得對應的基本型別值。 複習賦值運算子 NaN 不等於 NaN ，不論是在相等或全等的情況。 當兩個「物件」比較時，要看兩者是否指向同一個「實體」，只有在指向同一個「實體」時才會回傳 true 。 複習比較運算子 兩者都是數字時，單純就其字面大小比較。 如果其中一個是數字，另一方不是，則會先將另一方轉為數字再比較。 如果兩者都是字串，則會依照字母順序比較。 如果其中一個是布林值，會將 true 轉為數字的 1， false 則變成數字的 0。 如果其中一個是「物件」型別，而另一方是基本型別時，會先透過物件的 valueOf() 方式取得對應的基本型別值。 小知識 字母順序依照的規則為字典序（standard lexicographical ordering），要注意大小寫字母的順序並不同。 了解更多 Kuro－Boolean 的真假判斷：本文最主要的參考範例。 Summer－強制轉型：了解詳細的 JS 轉型規則。 Genos－強制轉型及轉換技巧：回顧 JS 的轉型規則。 Oh-My-Dear-JavaScript：觀看 JS 真值表。 "},{"title":"#16 邏輯運算子","date":"2023-11-08T16:00:00.000Z","url":"/javascript/20231109/3042451770/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"JS 的邏輯運算子和多數程式語言不同，其結果值並非只有 true 或 false 。 快速了解邏輯運算子有三種：AND、OR、NOT，照理來說，運算後會得到 true 或 false 的結果。然而在 JS 中，只有 NOT 運算子才會回傳 true 或 false 。AND 和 OR 運算子的回傳結果則不一定是 Boolean ，還可能會是兩個數值的其中之一。讓我們先來了解三種邏輯運算子的定義，再理解 JS 中的特殊規則。 ANDAND 以 &amp;&amp; 符號表示。在「多數程式語言」中表示「條件 A &amp;&amp; 條件 B」，當 &amp;&amp; 左右兩側的值都是 true 時，會得到 true 的結果；若其中一方是 false 則會得到 false 。不過，在 JS 中不是這樣運作。 OROR 以 || 符號表示。在「多數程式語言」中表示「條件 A || 條件 B」，當 || 左右兩側有一方為 true ，則結果是 true ；只有在兩側都是 false 時才會得到 false 。不過，在 JS 中不是這樣運作。 NOTNOT 以 ! 符號表示。原本是 true 的結果經過 ! 轉換後會得到 false ；而原本是 false 的結果則會變成 true 。 Boolean 的型別轉換JS 中可以分成兩種「值」：不是 true 就是 false。 經過 ToBoolean 轉換後得到 false 的值，這些被稱為「Falsy」值。 其他的值，即經過 ToBoolean 轉換後得到 true 的值，這些被稱為「Truthy」值。絕大部分的情況都會變成 true ，因此以下只提及會變成 false 的特例： undefined null +0 , -0 , NaN &#39;&#39; , ”” （空字串）除此之外，所有的狀況都是 true ，例如：0、 [] 、 &#123;&#125; 、 function()&#123;&#125; 、 &quot;&#39;&#39;&quot; （這並不是空字串）。 &amp;&amp; 與 || 的特殊案例相較於其他程式語言，JS 針對 &amp;&amp; 與 || 有不同的規範：結果並非布林值的 true 或 false ，而是兩個數值的其中之一。 &amp;&amp; 與 || 運算子在判斷時，會先對左邊的數值進行檢查： 若是 Boolean 就在做後續判斷；若不是，則會透過 ToBoolean 判斷是「truthy」或「falsy」，並以此轉換乘對應的 true 跟 false 。 對 &amp;&amp; 來說，若第一個數值轉換為 true ，則回傳第一個數值；否則回傳第二個數值。 對 || 來說，若第一個數值轉換為 false ，則回傳第二個數值；否則回傳第一個數值。 小知識 需要判斷某數值 Boolean 轉換後的結果時，可以透過兩次「NOT」操作，用 !!xxx 來取代 Boolean(xxx) 。 Falsy 值還有一種：本來就是 false 值者。同時要注意，Boolean(false) 和 Boolean(&quot;false&quot;) 的結果不同，前者是 false ；後者是字串，所以結果為 true。 了解更多 Kuro－Boolean 的真假判斷：本文最主要的參考範例。 Vicky－Truthy 與 Falsy：了解 Truthy 與 Falsy 的差異。 "},{"title":"#15 逗號運算子","date":"2023-11-07T16:00:00.000Z","url":"/javascript/20231108/1989175817/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"逗號運算子可以分隔運算式，或同時宣告多組變數。 快速了解逗號運算子主要工作為：用逗號分隔運算式，使其依序由左至右執行，並且會回傳最後一個運算式的值。 基本用法逗號運算子由逗號 , 表示，透過逗號運算子可以將多組運算式看作是同一個，最常出現在 for 迴圈中。 進階用法此外，逗號運算子也可以宣告變數。具體來說，可以同時宣告多組變數，且給予預設值。值得注意的是，若使用錯誤方式同時宣告多組變數，可能會造成「全域變數」的大麻煩！以下展示正確與錯誤的宣告方式。 錯誤改寫看似同時用 var 宣告 a、b 變數，並賦值「10」。然而，變數 b 並沒有被透過 var 宣告，而是一個全域變數。 了解更多 Kuro－Boolean 的真假判斷：本文最主要的參考範例。 MDN－逗號運算子：觀看更多逗號運算子的範例。 "},{"title":"#14 比較運算子","date":"2023-11-06T16:00:00.000Z","url":"/javascript/20231107/1239253188/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"相等會自動轉型，全等不會自動轉型。 快速了解比較運算子的用塗是比較運算子兩側數值，不論數值為純值、物件、運算式或函數回傳結果，比較結果都是 true 或 false。針對不同型別的數值，會先自動轉型到同樣型別後，再做比較。 前情提要只有一個等號，是「指定、賦值」的意思。當要比較數值時，有兩種表現方式：兩個等號的「相等」或三個等號的「全等」。這是 JS 最容易搞混的觀念之一！ 相等相等，以兩個等號 == 表示，在比較判斷時會自動轉型，是「寬鬆的等於」。當兩個不同的「資料型別」比較時，會觸發自動轉型，導致常常會出現莫名其妙的比較結果，因此，不建議使用相等來比較。 全等全等，以三個等號 === 表示，在比較判斷時不會自動轉型，是「嚴格的等於」。當兩個不同的「資料型別」比較時，不會自動轉型，因此，只會在雙方的「數值」與「型別」都相同時才回傳 true。在任何時刻都建議使用全等來比較。 不等於不等於有兩種版本：寬鬆的不等於 != 和嚴格的不等於 !== 。觀念和上述內容相同，前者會做自動轉型，後者不會做自動轉型。 重點回顧相等 == 和全等 === 都是比較的意思，它們的差異不是「全等會檢查型別而相等不會」，是：全等不會替數值做自動轉型，相等會做自動轉型。 運算子整理 運算子 說明 範例 結果 &#x3D;&#x3D; 相等，寬鬆的等於 1 == “1” true &#x3D;&#x3D;&#x3D; 全等，嚴格的等於 1 === “1” true !&#x3D; 寬鬆的不等於 10 != &quot;10&quot; false !&#x3D;&#x3D; 嚴格的不等於 10 !== &quot;10&quot; true 小知識 除了相等和全等之外，比較運算子還包括：大於 &gt; 、大於等於 &gt;= 、小於 &lt; 、小於等於 &lt;= 。 =&gt; 不是運算子，而是 ES6 的箭頭函式。 了解更多 Kuro－「比較」與自動轉型的規則：本文最主要的參考範例。 "},{"title":"#13 賦值運算子","date":"2023-11-05T16:00:00.000Z","url":"/javascript/20231106/2323189855/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"賦值運算子能讓運算的處理更簡潔、便利。 快速了解賦值運算子，或稱指派、指定運算子，用途為：指定一個值給一個變數。 基本用法只有一個等號 = 是「指定、指派、賦值」的意思。例如下方案例：用 &#x3D; 符號將右側的運算式結果「指派」給等號左側的變數 a。 進階用法賦值運算子還可以結合數學運算子，會先將等號右側的內容運算完成，再指定至等號左側的變數，例如： += 、 -= 。當賦值運算子的前後都是「數值」或「布林值」時，會視為數字後運算。而當其中一個是字串時，則觸發自動轉型，用字串聯結。例如下方案例： a += 10 代表 a = a + 10。 運算子整理 運算子 說明 範例 &#x3D; 將 y 值指定給 x 變數 x = y +&#x3D; 意思跟 x = x + y 一樣，將 x、y 相加後的值指定回 x 變數 x += y -&#x3D; 意思跟 x = x - y 一樣，將 x、y 相減後的值指定回 x 變數 x -= y *&#x3D; 意思跟 x = x * y 一樣，將 x、y 相乘後的值指定回 x 變數 x *= y &#x2F;&#x3D; 意思跟 x = x / y 一樣，將 x、y 相除後的值指定回 x 變數 x /= y %&#x3D; 意思跟 x = x % y 一樣，將 x 除以 y 的餘數指定回 x 變數 x %= y 小知識 實際上，賦值運算子的進階用法就是一般四則運算的懶人寫法。 了解更多 Kuro－Boolean 的真假判斷：本文最主要的參考範例。 JStips－賦值運算子：觀看更多賦值運算子的範例。 "},{"title":"#12 算術運算子：一元運算子","date":"2023-11-04T16:00:00.000Z","url":"/javascript/20231105/1630436862/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"一元運算子只需要單個數值就可以完成運算，有正號、負號、遞增、遞減四種。 快速了解算術運算子還有一種——只需要單個數值即可完成運算的「一元運算子」。 正號與負號正號 + 與負號 - 分別代表數字的「正數」與「負數」的狀態。 當後面是數字時，結果會是該數值的正數或負數。 當後面是非數字的基本型別時，會先以 Number() 嘗試轉型，再由正、負號決定其數值。 當後面是物件型別時，會先以 valueOf() 取得數值，再由正、負號決定其數值。 若得到 NaN，結果就是 NaN。 遞加與遞減「遞增」指變數遇上 ++ 就會加 1，也可以想成是 a=a+1；「遞減」指變數遇上 -- 就會減 1，也可以想成是 a=a-1。值得注意的是，這兩個運算子在變數的前、後，會產生不同的結果。當運算子在變數後面時，回傳結果會是「原始數值」；當運算子在變數前面時，回傳結果會是「+1 之後的結果」。但事後將結果印出時，回傳結果都會是「+1 之後的結果」。 運算子整理 運算子 說明 範例 + 一元正號運算子 +8 - 一元負號運算子 -x ++ 遞增運算子 a++ – 遞減運算子 5— 小知識 加號和 Number() 有一樣的數字轉型效果。 了解更多 Kuro－「比較」與自動轉型的規則：本文最主要的參考範例。 MDN－一元正號運算子（+）：觀看更多一元正號運算子的自動轉型範例。 MDN－一元負號運算子（-）：觀看更多一元負號運算子的自動轉型範例。 MDN－遞增運算子（++）：觀看更多遞增運算子的範例。 MDN－遞減運算子（–）：觀看更多遞減運算子的範例。 "},{"title":"#11 算術運算子：四則運算","date":"2023-11-03T16:00:00.000Z","url":"/javascript/20231104/3439418316/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"算術運算子除了能夠進行四則運算，還影響著型別間的自動轉型問題。 快速了解算術運算子包括數學四則運算的加、減、乘、除和取餘數。運算式會遵守「由左至右」且「先乘除後加減」的模式進行運算，需要時可加上小括號 () 輔助。 加號加法運算子以加號 + 表示。 當前後兩者都是數字時，計算結果是兩個數值的和。 當其中一個是 NaN 時，結果必定也是 NaN。 Infinity 與 -Infinity 的情況： Infinity 與 Infinity 相加，結果是 Infinity 。 -Infinity 與 -Infinity 相加，結果是 -Infinity 。 Infinity 與 -Infinity 相加，結果是 NaN。 當其中一個不是數字時，會觸發自動轉型。 若其中一個是字串，另一端會變「自動轉型」為字串後，連接在一起。 當另一端是數字、布林值、物件時，會以 .toString() 轉型。 當另一端是 null、undefined 時，會以 String() 將它們轉成 “null” 與 “undefined” 。 減號減法運算子以減號 - 表示。 當前後兩者都是數字時，計算結果是兩個數值的差。 當其中一個是 NaN 時，結果必定也是 NaN。 Infinity 與 -Infinity 的情況： Infinity 與 Infinity 相減，結果是 NaN。 -Infinity 與 -Infinity 相減，結果是 NaN。 -Infinity 與 Infinity 相減，結果是 -Infinity 。 Infinity 與 -Infinity 相減，結果是 Infinity 。 當其中一個不是數字時，會觸發自動轉型。 若其中一個是非數字的基本型別時，會以 Number() 嘗試轉為數字。 若其中一個是物件型別時，會先以 valueOf() 取得數值再計算；若物件沒有 valueOf() 方法的話，則會先透過 toString() 轉成字串，再以 Number() 後的數字進行運算。 乘號乘法運算子以星號 * 表示。 當前後兩者都是數字時，計算結果是兩個數值的乘積。 若計算結果超出數字範圍，會依結果是正數或負數決定是 Infinity 或 -Infinity。 當其中一個是 NaN 時，結果必定也是 NaN。 若其中一個不是數字時，JS 會先嘗試以 Number() 進行轉型再運算。 除號除法運算子以斜線 / 表示。 當前後兩者都是數字時，計算結果是兩個數值的商。 當其中一個是 NaN 時，結果必定也是 NaN。 若其中一個不是數字時，JS 會先嘗試以 Number() 進行轉型再運算。 在被除數為 0 時，有三種情況： 除數為正數，結果為 Infinity。 除數為負數，結果為 -Infinity。 除數為 0，結果為 NaN。 取餘數取餘數運算子以百分比符號 % 表示。 當前後兩者都是數字時，計算結果是除法運算後的「餘數」。 當被除數是 Infinity 或 -Infinity 時，取餘數結果會是 NaN。 當被除數是一般數值，而除數為 Infinity 時，結果為被除數。 當被除數是一般數值，而除數為 0 時，結果為 NaN。 當其中一個是 NaN 時，結果必定也是 NaN。 若其中一個不是數字時，JS 會先嘗試以 Number() 進行轉型再運算。 運算子整理 運算子 說明 範例 + 加法 10 + ”hello” - 減法 100 - false * 乘法 100 * 5 &#x2F; 除法 20 / 2 % 取餘數 100 % 33 小知識 算術運算子還有一種：指數運算子，以雙星號 ** 表示，用來計算以 a 為底的 b 次方。 了解更多 Kuro－運算式與運算子：本文最主要的參考範例。 MDN－加法運算子（+）：觀看更多加法運算子的自動轉型範例。 MDN－減法運算子（-）：觀看更多減法運算子的自動轉型範例。 Genos－強制轉型及轉換技巧：預習 JS 的轉型規則。 "},{"title":"#10 運算式與運算子","date":"2023-11-02T16:00:00.000Z","url":"/javascript/20231103/808747970/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"JS 可分為陳述式與運算式，最關鍵的差異為是否會回傳結果。 快速了解JS 的語法基本上可以分為兩類：陳述式與運算式。 陳述式（Statement）：會執行一些程式碼，且不會回傳結果，像是變數宣告、賦值、流程判斷、迴圈等。 運算式（Expression）：會回傳結果。換言之，任何可回傳結果都可稱為運算式，像是純值、變數、運算子、執行函式等。 重點整理 是否會回傳結果？ 常見分類 陳述式 不會回傳結果。 變數宣告、賦值、流程判斷、迴圈等。 運算式 會回傳結果。 純值、變數、運算子、執行函式等。 運算子在運算式中，存在很多種運算子（Operator），它們可以對值進行運算，進而得到運算結果。常見運算子包含：算術運算子、位元運算子、比較運算子、賦值運算子、邏輯運算子等。 小知識 運算式又稱「表達式」。 學習陳述式和運算式概念時，建議搭配 Chrome 的開發者工具。 了解更多 卡斯柏－JavaScript 表達式觀念及運用 - JS Expression：熟悉陳述式與表達式的差異。 itsems－Javascript 的表達式和陳述式：觀看更多表達式案例。 "},{"title":"#9 物件型別：陣列","date":"2023-11-01T16:00:00.000Z","url":"/javascript/20231102/712042596/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"陣列是有順序性的集合，透過內建函式可以新增、刪除陣列中的元素。 快速了解陣列可被視為一種特別的「物件」，同樣是零至多個元素的集合，其值可以是原始的資料型別、另一個陣列、物件甚至函式。與物件不同，陣列是有順序性的集合。 建立陣列陣列有兩種宣告方式：建構式與陣列實字。 建構式：用 new 關鍵字加上 Array() 來宣告一個物件。 陣列實字：用 [] 就可以宣告一個物件。 陣列索引陣列索引是由 0 開始計算，以下方案例來說，陣列索引依序是 0、1、2、3。陣列長度則可以透過 array.length 得知。 陣列元素取值陣列元素的取值方式為 array[number] ，number 指元素的索引值。舉例來說：陣列的第一個元素，要透過 array[0] 取得。 新增元素陣列有兩種新增元素的方式： push() 、 unshift() 。 push() ：加入項目至陣列末端。 unshift() ：加入項目至陣列前端。 刪除元素陣列有三種刪除元素的方式： pop() 、 shift() 、 splice() 。 pop() ：移除陣列末端的項目。 shift() ：移除陣列前端的項目。 splice() ：移除指定索引位置的項目，並可指定欲移除其後的多少個項目。 陣列判斷使用 typeof 檢查一個陣列，會得到 “object” 的結果。當我們要檢查一個變數是陣列而非物件時，可以透過 isArray() 的方法判斷： 小知識 array.length 的值可被覆寫，因此，陣列長度可以透過改變 length 屬性而更動。 了解更多 MDN－Array：了解陣列的更多應用。 MDN－Array.length：熟悉 array.length 的操作邏輯。 卡斯柏－JS 常見陣列方法：理解 JS 常見的陣列方法。 "},{"title":"#8 物件型別：物件","date":"2023-10-31T16:00:00.000Z","url":"/javascript/20231101/3927311135/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"物件型別對於 JS 來說是非常重要且容易混淆的概念，其包含物件、陣列、函式等值。 快速了解複習一下，除了六種基本型別之外的值，都可以被歸類為「物件型別」。因此，物件、陣列、函式都屬於物件型別。 物件定義一個物件（object）可以是個零至多種屬性的集合，而屬性是名稱（name）與值（value）之間的關聯。一個屬性的「值」可以是某個基本型別，也可以是另一個物件，甚至是一個函式。物件內容來源有兩種：瀏覽器預先定義、開發者自己定義。 瀏覽器或執行環境預先定義，例如：window、Date、Math 等物件。 開發者自己定義物件的屬性與內容。 建立物件物件有兩種宣告方式：物件建構式與物件實字。 物件建構式：用 new 關鍵字加上 Object() 來宣告一個物件。 物件實字：用 &#123;&#125; 就可以宣告一個物件。 物件屬性取值物件的屬性有兩種取值方式：點記法與括弧記法。 點記法：使用 . （點）進行取值，語法為 objectName.propertyName。 括弧記法：使用 [] （中括弧）進行取值，語法為 objectName[&quot;propertyName&quot;]。 新增屬性使用 = （等號）指定，即可為物件新增屬性。 刪除屬性使用 delete 關鍵字，即可刪除屬性。屬性刪除後，該變數的值會變成 undefined。 小知識 因為 JSON 的特性，當屬性名稱是數字開頭時，使用點記法取值會出現錯誤，例如：”001” 。這時就必須改成括弧記法 objName[”001”] 的方式才能正確存取值。 當我們存取物件中不存在的屬性時，會回傳 undefined。因此，可以透過檢查某屬性是否為 undefined，來判斷屬性是否存在。除了此方式，還有兩種進階方法：in 運算子與 hasOwnProperty() 函式。 了解更多 卡斯柏－JS 物件名詞解釋及常見觀念問題：了解物件相關知識。 JSON 精要讀書紀錄－JSON 語法：預習 JSON 格式的使用方式。 MDN－關係運算子：in 運算子判斷屬性是否存在。 MDN－Object.prototype.hasOwnProperty()：hasOwnProperty() 函式判斷屬性是否存在。 "},{"title":"#7 基本型別：布林值、null、undefined 與 symbol","date":"2023-10-30T16:00:00.000Z","url":"/javascript/20231031/2849981050/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"簡介布林值、 null 、 undefined 與 symbol 等資料型別的常見應用。 快速了解boolean布林值（boolean）通常用在判斷式，作為控制程式流程的用途。其值只有兩種：true 及 false。 nullnull 型別只有一種值——null（空值），代表「此變數可能曾經有值，也可能沒有值，現在沒有值」。例如：以下案例中的 a ，明確表示此變數沒有值。 undefinedundefined 型別也只有一種值——undefined，代表「此變數還沒有給值，所以不知道是什麼」。例如：以下案例的 b，當變數 b 被宣告時，其值還沒有定義或還未指定的情況下，預設值會是 undefined。 symbolsymbol 是 ES6 新增的基本資料型別，用來表示獨一無二的值，以避免名稱相同造成的衝突。 小知識 在 JS 判斷比較的運算式中，所有內容都可以轉換為布林值。 typeof null 回傳結果是“obejct” ，而非 null。這其實是一個 Bug！但因為修正該問題，會影響太多舊程式，最後只好保留這個錯誤。 了解更多 fooish－JavaScript ES6 Symbol 資料型態：了解 Symbol 的使用情境。 stackoverflow－Why is typeof null “object”?：明白 typeof null 為什麼是 “obejct” 。 "},{"title":"#6 基本型別：數字","date":"2023-10-29T16:00:00.000Z","url":"/javascript/20231030/4193996687/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"數字型別除了基礎運算， NaN 與浮點數問題也相當重要。 快速了解JS 只有一種數字的型別，不論整數、浮點數，或 Infinity（無限大）、-Infinity（負無限大）及 NaN（不是數值）等特殊數字，都屬於 number 型別。 數字使用方式數字有兩種使用方式：字面常量與科學記號表示法。 字面常量： 科學記號表示法： 無限的計算方式Infinity 與 -Infinity 分別代表數學上的無限大與負無限大。任何正數除以 0，結果會得到 Infinity；相反的，任何負數除以 0，結果會是 -Infinity。 NaNNaN 不等於任何數字，甚至是自己。因此，它與任何數字運算，結果都是 NaN。然而，使用 typeof 判斷 NaN 型別時，回傳結果卻是數字。那麼該如何判斷一個變數是否為 NaN 呢？可以透過 isNaN(value) 函式來協助： 浮點數JS 在運算 0.1 + 0.2 時，其結果不是 0.3，而是 0.30000000000000004 。因此執行 0.1 + 0.2 === 0.3 會回傳 false 的結果。這是因為 JS 採用「IEEE 754」六十四位元二進位浮點數算術標準，十進位的小數無法完美的用二進位表示，只能用無限循環的位數來趨近於十進位的小數，導致還原時的小數不夠精準。透過 toFixed() 和 toPrecision() 設定精確度，可以避免浮點數問題。例如：設定精確到小數第一位。 小知識 數字型別常搭配 Math 物件使用，例如： Math.PI 可用來計算圓周和直徑。 了解更多 MDN－Math 物件：了解 Math 的常見用法。 MDN－NaN：了解 NaN 的使用方式與相關限制。 Floating Point Math：解釋 0.1 + 0.2 !== 0.3 的原理與彙整各程式語言計算方式。 "},{"title":"#5 基本型別：字串","date":"2023-10-28T16:00:00.000Z","url":"/javascript/20231029/3345115497/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"字串型別原本專門儲存、處理文字，樣板字面值的出現，大幅提升字串的靈活度。 快速了解在 JS 中，文字會以字串表示。 字串使用方式字串會用一組單引號 ’’ 或雙引號 ”” 包住，且兩者不可混用。 在單引號中包覆單引號，或在雙引號中包覆雙引號都會出現問題。如果非用不可，可以透過跳脫字元 \\ 處理： 遇到多組字串時，可以透過加號 + 連接： 或是在多行字串時，使用反斜線 \\ 連結： 樣板字面值樣板字元值（template literal）是 ES6 新增的特殊字串，支援多行字串、允許將變數嵌入字串，且能夠內嵌運算式，大幅提升字串的靈活度。樣板字元值由反引號 &#96;&#96;&#96;&#96; 所包覆，由一般字串、錢字號 $ 、大括弧 &#123;&#125; 組成。 支援多行字串： 允許將變數嵌入字串 內嵌運算式： 小知識 連接多行字串時，反斜線 \\ 後方不可以有任何內容，包括空白字元。 反引號位於鍵盤左上方，Esc 底下。 了解更多 MDN－樣板字面值：了解樣板字面值的詳細內容與更多範例。 PJCHENder－樣板字面值：了解樣板字面值的應用。 菜鳥教程－HTML DOM console.log() 方法：簡介 console.log 用法。 "},{"title":"#4 資料型別簡介","date":"2023-10-27T16:00:00.000Z","url":"/javascript/20231028/764880996/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"變數沒有型別，值才有。 快速了解變數本身不帶有資料型別的資訊，其中的「值」或「物件」才有。換句話說，變數只是用來作為取得值或物件的參考。JS 的資料型別分為兩大類：基本型別（Primitives）與物件型別（Object）。 資料型別總共有七種資料型別：六種基本型別及一種物件型別。 字串（String）。 數字（Number）。 布林值（Boolean）。 null。 undefined。 symbol。 物件型別（Object）。 型別判斷可以透過 typeof 運算子判斷型別。 型別整理 資料型別 說明 String 字串。 Number 數字，可以是整數或小數。 Boolean 布林值，只有 true、false 兩種。 null 空值，表示參考值不存在。 undefined 未定義，宣告變數卻未指派內容給它。 symbol 符號，表示獨一無二的值。 object 物件、陣列、函式都屬於物件型別。 小知識 JS 是一種「弱型別語言」，宣告變數時，可以不指定該值的資料型別。編譯時，JS 會將該變數轉換成「可以被執行」的資料型別，並強制執行。 基本型別之外的值，都是「物件型別」。 了解更多 MDN－資料結構與型別：了解 JS 各資料型別的基本內容。 Yi-Ning－關於 JavaScript 的弱型別特性：了解弱型別語言的定義。 "},{"title":"#3 變數","date":"2023-10-26T16:00:00.000Z","url":"/javascript/20231027/1250803838/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"變數是儲存資料的容器，可以幫助我們紀錄、使用資訊。 快速了解變數是什麼？變數（Variables）是用來儲存資料和進行運算的基本單位，可以將變數想像為一個盒子，用來存放資料。變數儲存的資料被稱為「值」（value）。 變數的命名規則 變數的第一個字母必須是英文字母、底線 _ 或錢字號 $ ，後面可以是英文字母、底線 _ 或錢字號 $ 及數字 變數名稱不可以是保留字和關鍵字。 區分大小寫， app 和 App 會被視為不同變數。 變數的宣告方式變數有三種宣告方式： var 、 let 、 const 。差異為變數作用範圍、能否重複宣告等。變數必須經過宣告才能使用，如果在沒有宣告變數的情況下使用，會出現錯誤。 小知識 JS 支援 Unicode，變數名稱可以用中文命名。但基於開發習慣，仍應該避免使用英文字母、底線（_）或錢字號（$）以外的字原來命名變數。 事實上，變數還有第四種宣告方式：無宣告。但沒有經過宣告的變數都會變成全域變數，可能會造成維護困難，因此非常不建議這麼做！ 了解更多 MDN－存儲您需要的資訊 - 變數：詳細說明 JS 變數的使用規則。 W3School－JavaScript Reserved Words：JS 的保留字列表。 阿建－JavaScript 變數宣告有哪些?必須弄懂的4個重點：了解 JS 的四種變數宣告。 Roy Kwok－Unicode 與 UTF-8 的關係？：說明 Unicode 如何編譯中文字元。 "},{"title":"#2 JS 發展簡史","date":"2023-10-25T16:00:00.000Z","url":"/javascript/20231026/1784042972/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"JavaScript 如何從「網路特效工具箱」發展成網頁設計中不可或缺的一部份？ 背景故事JS 最初的設計目標是：在文件閱讀上增加互動，讓網站動起來。1995～2010 年這段期間，處於瀏覽器的戰國時代，各種瀏覽器百花齊放，且各家標準不一，造成網頁維護困難。ECMA 組織於 1997 年發表 JS 的標準化版本——ECMAScript，使 JS 開始獲得廣泛支持，成為瀏覽器唯一指定的內建程式語言。2015 年，ECMAScript 第六版本（簡稱 ES2015、ES6）發布前，有很多 JS 的延伸語言存在，例如：CoffeeScript、TypeScript、Dart 等，這些都是使用者因應需求，自行開發的程式語言。ES6 整合了上述延伸語言的優點並新增許多重要規範，使 JS 更強大，以便開發複雜的應用程式。從此，ES6 成為主流使用的 JS 標準。 小知識 Java 和 JavaScript 之間類似於「臘腸」和「臘腸狗」的關係——沒有關係。 TypeScript 是有型態規範的 JS，由微軟開發，有較嚴謹的寫法。直到今日，仍有許多開發者使用。 2015 年之後，ECMAScript 在每年六月會推出最新的版本，例如：ES2016、ES2017⋯⋯，這些新版本被統稱為「ES6+」。 了解更多 Kuro Hsu－重新認識 JavaScript: Day 02 JavaScript 簡介：圖文並茂講古時間。 ALPHACamp－JavaScript 前世今生：了解前端發展歷史。 "},{"title":"#1 JS 是什麼？","date":"2023-10-24T16:00:00.000Z","url":"/javascript/20231025/1925797630/","tags":[["JavaScript","/tags/JavaScript/"]],"categories":[["DoJS","/categories/javascript/"]],"content":"JavaScript 不是魔法，而是一種實現多樣化功能的程式語言。 快速了解JS 是什麼樣的程式語言？ JS 是一種腳本程式語言，具有簡單、易學、易用的特性。 JS 是一種直譯式語言，其程式碼由上到下執行，且能夠立即得到執行結果。 JS 是一種動態程式，會在瀏覽器上調整 HTML 與 CSS，以產生新的內容，並在頁面中呈現。因為此特性，使它必需在 HTML、CSS 之後載入，否則可能會發生錯誤。 JS 的功能JS 可以在網頁中展現複雜的動態功能，例如：表單驗證、彈跳動畫等互動行為。基礎的 JS 可以進行四則運算、數字排序、判斷大小寫等。若加上應用程式介面（API），還能提供 JS 額外的功能，例如：內容即時更新、繪製 2D&#x2F;3D 圖形、影片播放控制。 JS 載入方式JS 主要有兩種載入方式：內部與外部。 內部的 JS：在 HTML 檔案的 &lt;/head&gt; 結尾標籤前加入以下文字。 外部的 JS：建立一個以 .js 為副檔名的檔案，將 JS 內容寫在該檔案內，並在 HTML 檔案的 &lt;/head&gt; 或 &lt;/body&gt; 結尾標籤前加入以下文字。 JS 註解方式JS 有兩種註解方式：單行和多行。 單行註解：文字寫在兩個斜線 // 之後。 多行註解：文字寫在 /* 和 */ 之間。 了解更多 MDN－JavaScript 是什麼？：詳細說明 JS 的能力與使用方式。 MuleSoft Videos－What is an API?：了解 API 在網頁中扮演的角色與功能。 "},{"title":"⚡️ 最聰明的高效能溝通法","date":"2023-10-23T16:00:00.000Z","url":"/read/20231024/861377249/","tags":[["閱讀心得","/tags/%E9%96%B1%E8%AE%80%E5%BF%83%E5%BE%97/"]],"categories":[["DoRead","/categories/read/"]],"content":"我們平均花 26 秒閱讀一篇內容，卻仍用 80 年代的舊方式溝通。 為什麼重要：資訊爆炸的現在，若使用冗長的舊方法溝通，每天將會有數十億個文字成為無法被消化的成本，這些巨量文字不斷地轟炸你、浪費你的時間。「聰明簡潔溝通法」能為你帶來自信，成為更有力的溝通者，同時也能讓更多人聽見你的聲音。 什麼是「聰明簡潔溝通法」？「聰明簡潔溝通法」有四個核心觀念： 強大的「引子、標題」。 有力、令人難忘的「導言」。 交代背景脈絡的「為什麼重要」。 補充說明的「了解更多」。 透過這四個核心觀念的系統，能夠讓你用更少的時間分享更多的價值。「少即是多」的寫作精神，才是符合當前網路世代的交流模式。並且，不論簡報、電子郵件、社群軟體，任何溝通方法都適用！ 了解更多 Axios.com：看看聰明簡潔溝通法如何運作。 《聰明簡潔的溝通》：書籍購買連結。 書籍資訊 書名：聰明簡潔的溝通：200 字寫重點，26 秒贏得注意力 作者：吉姆．范德海、麥克．艾倫、羅伊．史瓦茲 出版社：天下文化 "},{"title":"404","date":"2023-10-27T16:00:00.000Z","url":"/404.html","categories":[[" ",""]],"content":"這是一個不存在的頁面很抱歉，你目前存取的頁面並不存在。預計將在約 5 秒後返回首頁。如果你很急著想看文章，你可以 點這裡 返回首頁。 let countTime = 5; function count() { document.getElementById('timeout').textContent = countTime; countTime -= 1; if(countTime === 0){ location.href = ''; } setTimeout(() => { count(); }, 1000); } count(); "},{"title":"About","date":"2023-10-28T15:58:19.043Z","url":"/about/index.html","categories":[[" ",""]]},{"title":"archives","date":"2023-10-24T16:00:00.000Z","url":"/archives/index.html","categories":[[" ",""]]},{"title":"category","date":"2023-10-24T16:00:00.000Z","url":"/categories/index.html","categories":[[" ",""]]},{"title":"search","date":"2023-10-24T16:00:00.000Z","url":"/search/index.html","categories":[[" ",""]]},{"title":"tags","date":"2023-10-24T16:00:00.000Z","url":"/tags/index.html","categories":[[" ",""]]}]